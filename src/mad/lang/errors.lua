local M  = { help = {}, test = {} }

-- MAD -------------------------------------------------------------------------

M.help.self = [[
NAME
  mad.lang.errors
  
SYNOPSIS
  local errorHandler = require "mad.lang.errors"()
  errorHandler.setCurrentChunkName(chunkname)
  errorHandler:addToLineMap(astNode.line, generator.writtenLine, chunkName)
  errorHandler:handleError(errmess, trace)
  
DESCRIPTION
  Maps lines from the generated lines to the input lines, making errormessages
  report lines on the place where they are written by the user, instead of 
  where they are generated by Lua.
  
  local errorHandler = require "mad.lang.errors"()
    Creates a new instance of the errorhandler
  errorHandler.setCurrentChunkName(chunkname)
    Sets the chunkname to be used by the parser
  errorHandler:addToLineMap(astNode.line, generator.writtenLine, chunkName)
    Adds a line to the map
  errorHandler:handleError(errmess, trace)
    Makes an error report to the correct lines in the original files.
    
RETURN VALUES
  A table with call semantic to initiate an instance.
  
SEE ALSO
  None
]]

-- modules ---------------------------------------------------------------------

local setCurrentChunkName = function(self, name)
	self.currentChunkName = name
	if not self._lineMap[self.currentChunkName] then
		self._lineMap[self.currentChunkName] = {}
	end
end

local addToLineMap = function(self, lineIn, lineOut, fileName)
	if not self._lineMap[self.currentChunkName][lineOut] then
		self._lineMap[self.currentChunkName][lineOut] = {}
	end
	self._lineMap[self.currentChunkName][lineOut].fileName = fileName
	if not self._lineMap[self.currentChunkName][lineOut].line or lineIn and self._lineMap[self.currentChunkName][lineOut].line > lineIn then
		self._lineMap[self.currentChunkName][lineOut].line = lineIn
	end
end

local function searchForLineMatch(self, line, chunkName)
	if self._lineMap[chunkName][line+1] then
		line = line+1
	else
		while line > 1 and not self._lineMap[chunkName][line] do
			line = line - 1
		end
	end
	return line
end

local function getNameAndLine(self, err, chunkName)
	local line = tonumber(string.match(err, ":(%d+):"))
	if not self._lineMap[chunkName][line] then
		line = searchForLineMatch(self, line, chunkName)
	end
	local name = self._lineMap[chunkName][line].fileName
	local realLine = self._lineMap[chunkName][line].line
	return name, realLine
end

local function getErrorMessage(err)
	return string.match(err,":%d+:%s*(.+)")
end

local function getStackTraceBack(err)
	return string.match(err, ".*stack traceback:%s*(.*)%s*%[C%]: in function 'xpcall'")
end

local function createStackTable(self, stack)
	local stacktable = {}
	for s in string.gmatch(stack,"(.-)\n%s*") do
	    local chunkName = string.match(s,"(.-):%d+:")
		local name, line = getNameAndLine(self, s, chunkName)
		stacktable[#stacktable+1] = "\t"..name..":"..line..":"..string.match(s,":%d+:(.*)")
	end
	return stacktable
end

local function createStackErrorMessage(stacktable)
	local errmess = "\nstack traceback:"
	for i,v in ipairs(stacktable) do
		errmess = errmess..'\n'..v
	end
	return errmess
end

local function getChunkName(err)
	return string.match(err, "(.-):%d+:")
end

local function translateLuaErrToMadErr(self, err, trace)
	local chunkName = getChunkName(err)
	local name, realLine = getNameAndLine(self, err, chunkName)
	local errmess = getErrorMessage(err)
	errmess = name..":"..realLine..": "..errmess
	local stack = getStackTraceBack(trace)
	local stacktable = createStackTable(self, stack)
	errmess = errmess..createStackErrorMessage(stacktable)
	return errmess
end

local function handleError (self, err, trace)
	local errmess = translateLuaErrToMadErr(self, err, trace)
	return errmess
end

-- metamethods ----------------------------------------------------------------
local mt = {}; setmetatable(M, mt)
mt.__call = function (_, ...)
	local self = {
		_lineMap = {},
		currentChunkName,
		setCurrentChunkName = setCurrentChunkName,
		addToLineMap = addToLineMap,
		handleError = handleError
	}
	return self
end

-- tests ----------------------------------------------------------------------

function M.test:setUp()
    self.errors = M()
    self.errors._lineMap = { chunk = { 
        { fileName = 'fn',  line = 1 },  --1
        { fileName = 'fn',  line = 2 },  --2
        { fileName = 'fn',  line = 3 },  --3
        { fileName = 'fn',  line = 3 },  --4
        { fileName = 'fn2', line = 1 },  --5
        { fileName = 'fn2', line = 2 },  --6
        { fileName = 'fn',  line = 7 },  --7
        { fileName = 'fn',  line = 8 }}} --8
end

function M.test:tearDown()
    self.errors._lineMap = nil
    self.errors = nil
end

function M.test:setCurrentChunkName(ut)
    ut:succeeds(self.errors.setCurrentChunkName, self.errors, 'Hallaien')
    ut:equals(self.errors.currentChunkName, 'Hallaien')
    ut:succeeds(self.errors.setCurrentChunkName, self.errors, 'Eg likar banan')
    ut:equals(self.errors.currentChunkName, 'Eg likar banan')
end

function M.test:addToLineMap(ut)
    self.errors:setCurrentChunkName'chunk'
    ut:succeeds(self.errors.addToLineMap, self.errors, 9, 10, 'fn3')
    ut:equals(self.errors._lineMap.chunk[10].line, 9)
    ut:equals(self.errors._lineMap.chunk[10].fileName, 'fn3')
    ut:succeeds(self.errors.addToLineMap, self.errors, 10, 1, 'fn')
    ut:equals(self.errors._lineMap.chunk[1].line, 1)
    ut:equals(self.errors._lineMap.chunk[1].fileName, 'fn')
    self.errors:setCurrentChunkName'chunk2'
    ut:succeeds(self.errors.addToLineMap, self.errors, 9, 10, 'fn3')
    ut:equals(self.errors._lineMap.chunk2[10].line, 9)
    ut:equals(self.errors._lineMap.chunk2[10].fileName, 'fn3')
    ut:succeeds(self.errors.addToLineMap, self.errors, 10, 1, 'fn')
    ut:equals(self.errors._lineMap.chunk2[1].line, 10)
    ut:equals(self.errors._lineMap.chunk2[1].fileName, 'fn')
end

function M.test:searchForLineMatch(ut)
    self.errors:setCurrentChunkName'chunk'
    self.errors:addToLineMap(14, 14, 'fn')
    self.errors:addToLineMap(12, 12, 'fn')
    self.errors:addToLineMap(15, 15, 'fn')
    local line = ut:succeeds(searchForLineMatch, self.errors, 9, 'chunk')
    ut:equals(line, 8)
    line = ut:succeeds(searchForLineMatch, self.errors, 2, 'chunk')
    ut:equals(line, 3)
    line = ut:succeeds(searchForLineMatch, self.errors, 11, 'chunk')
    ut:equals(line, 12)
    line = ut:succeeds(searchForLineMatch, self.errors, 10, 'chunk')
    ut:equals(line, 8)
    line = ut:succeeds(searchForLineMatch, self.errors, 13, 'chunk')
    ut:equals(line, 14)
    line = ut:succeeds(searchForLineMatch, self.errors, 100, 'chunk')
    ut:equals(line, 15)
end

function M.test:getNameAndLine(ut)
    local name, line = ut:succeeds(getNameAndLine, self.errors, "chunk:1:Some kind of error", 'chunk')
    ut:equals(name, "fn")
    ut:equals(line, 1)
    name, line = ut:succeeds(getNameAndLine, self.errors, "chunk:12:Some kind of error", 'chunk')
    ut:equals(name, "fn")
    ut:equals(line, 8)
    name, line = ut:succeeds(getNameAndLine, self.errors, "chunk:5:Some kind of error", 'chunk')
    ut:equals(name, "fn2")
    ut:equals(line, 1)
end

function M.test:getErrorMessage(ut)
    local errmess = ut:succeeds(getErrorMessage, [[./mad/lang/errors.lua:184: '=' expected near '+'
stack traceback:
	[C]: at 0x004504e0
	[C]: in function 'require'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
    ut:equals(errmess, [['=' expected near '+'
stack traceback:
	[C]: at 0x004504e0
	[C]: in function 'require'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
    errmess = ut:succeeds(getErrorMessage, [[:213:name]])
    ut:equals(errmess, [[name]])
end

function M.test:getStackTraceBack(ut)
    local stb = ut:succeeds(getStackTraceBack, [[./mad/lang/errors.lua:184: '=' expected near '+'
stack traceback:
	stuffhanppfewpfkw
	fewf
	hrthrst43t
	h
	grte
	
	few
	[C]: in function 'xpcall'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
    ut:equals(stb, [[stuffhanppfewpfkw
	fewf
	hrthrst43t
	h
	grte
	
	few
	]])
    stb = ut:succeeds(getStackTraceBack, [[./mad/lang/errors.lua:184: '=' expected near '+'
stack traceback:
	[C]: at 0x004504e0
	[C]: in function 'require'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
    ut:equals(stb, nil)
    stb = ut:succeeds(getStackTraceBack, [[:213:name]])
    ut:equals(stb, nil)
end

function M.test:createStackTable(ut)
    local stbl = ut:succeeds(createStackTable, self.errors, [[chunk:1:error
chunk:2:error2
chunk:5:error5
chunk:9:error9
]])
    ut:equals(stbl, { "\tfn:1:error", "\tfn:2:error2", "\tfn2:1:error5", "\tfn:8:error9" })
end

function M.test:createStackErrorMessage(ut)
    local st = ut:succeeds(createStackErrorMessage, { '1','2','3','4','5' })
    ut:equals(st, [[

stack traceback:
1
2
3
4
5]])
end

function M.test:getChunkName(ut)
    local ch = ut:succeeds(getChunkName,[[./mad/lang/errors.lua:184: '=' expected near '+']])
	ut:equals(ch, "./mad/lang/errors.lua")
    ch = ut:succeeds(getChunkName,[[./mad/lang/errors.lua:184: '=' expected near '+'
stack traceback:
	[C]: at 0x004504e0
	[C]: in function 'require'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
	ut:equals(ch, "./mad/lang/errors.lua")
end

function M.test:translateLuaErrToMadErr(ut)
    local transmess = ut:succeeds(translateLuaErrToMadErr, self.errors, "chunk:1:error1", 
[[stack traceback:
	chunk:2:error2
	chunk:5:error5
	chunk:10:error10
	[C]: in function 'xpcall'
	]])
    ut:equals(transmess, [[fn:1: error1
stack traceback:
	fn:2:error2
	fn2:1:error5
	fn:8:error10]])
end

function M.test:handleError (ut)
    local transmess = ut:succeeds(self.errors.handleError, self.errors, "chunk:1:error1", 
[[stack traceback:
	chunk:2:error2
	chunk:5:error5
	chunk:10:error10
	[C]: in function 'xpcall'
	]])
    ut:equals(transmess, [[fn:1: error1
stack traceback:
	fn:2:error2
	fn2:1:error5
	fn:8:error10]])
end


-- end ------------------------------------------------------------------------
return M
