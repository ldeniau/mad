local M  = { help = {}, test = {} }

-- MAD -------------------------------------------------------------------------

M.help.self = [[
NAME
  mad.lang.errors
  
SYNOPSIS
  local errorHandler = require "mad.lang.errors"()
  errorHandler.setCurrentChunkName(chunkname)
  errorHandler:addToLineMap(astNode.line, generator.writtenLine, chunkName)
  errorHandler:handleError(errmess, trace)
  
DESCRIPTION
  Maps lines from the generated lines to the input lines, making errormessages
  report lines on the place where they are written by the user, instead of 
  where they are generated by Lua.
  
  local errorHandler = require "mad.lang.errors"()
    Creates a new instance of the errorhandler
  errorHandler.setCurrentChunkName(chunkname)
    Sets the chunkname to be used by the parser
  errorHandler:addToLineMap(astNode.line, generator.writtenLine, chunkName)
    Adds a line to the map
  errorHandler:handleError(errmess, trace)
    Makes an error report to the correct lines in the original files.
    
RETURN VALUES
  A table with call semantic to initiate an instance.
  
SEE ALSO
  None
]]

-- modules ---------------------------------------------------------------------

local _lineMap = {}
local currentChunkName

M.setCurrentChunkName = function( name)
	currentChunkName = name
	if not _lineMap[currentChunkName] then
		_lineMap[currentChunkName] = {}
	end
end

M.addToLineMap = function( lineIn, lineOut, fileName)
	if not _lineMap[currentChunkName][lineOut] then
		_lineMap[currentChunkName][lineOut] = {}
	end
	_lineMap[currentChunkName][lineOut].fileName = fileName
	if not _lineMap[currentChunkName][lineOut].line or lineIn and _lineMap[currentChunkName][lineOut].line > lineIn then
		_lineMap[currentChunkName][lineOut].line = lineIn
	end
end

local function searchForLineMatch( line, chunkName)
	if _lineMap[chunkName][line+1] then
		line = line+1
	else
		while line > 1 and not _lineMap[chunkName][line] do
			line = line - 1
		end
	end
	return line
end

local function getNameAndLine( err, chunkName)
	local line = tonumber(string.match(err, ":(%d+):"))
	if not _lineMap[chunkName][line] then
		line = searchForLineMatch( line, chunkName)
	end
	local name = _lineMap[chunkName][line].fileName
	local realLine = _lineMap[chunkName][line].line
	return name, realLine
end

local function getErrorMessage(err)
	return string.match(err,":%d+:%s*(.+)")
end

local function getStackTraceBack(err)
	local str = string.match(err, ".*stack traceback:%s*(.-)%s*%[C%]: in function 'xpcall'")
	if str then return str.."\n" end
	return nil
end

local function createStackTable(stack)
	local stacktable = {}
	for s in string.gmatch(stack,"(.-)\n%s*") do
	    local chunkName = string.match(s,"(.-):%d+:")
		local name, line = getNameAndLine( s, chunkName)
		stacktable[#stacktable+1] = "\t"..name..":"..line..":"..string.match(s,":%d+:(.*)")
	end
	return stacktable
end

local function createStackErrorMessage(stacktable)
	local errmess = "\nstack traceback:"
	for _,v in pairs(stacktable) do
		errmess = errmess..'\n'..v
	end
	return errmess
end

local function getChunkName(err)
	return string.match(err, "(.-):%d+:")
end

local function translateLuaErrToMadErr( err, trace)
	local chunkName = getChunkName(err)
	local name, realLine = getNameAndLine( err, chunkName)
	local errmess = getErrorMessage(err)
	errmess = name..":"..realLine..": "..errmess
	local stack = getStackTraceBack(trace)
	local stacktable = createStackTable(stack)
	errmess = errmess..createStackErrorMessage(stacktable)
	return errmess
end

function M.handleError (err, trace)
	local errmess = translateLuaErrToMadErr(err, trace)
	return errmess
end

-- tests ----------------------------------------------------------------------

if not load_test then return M end

function M.test:setUp()
    self.errors = M
    _lineMap = { chunk = { 
        { fileName = 'fn',  line = 1 },  --1
        { fileName = 'fn',  line = 2 },  --2
        { fileName = 'fn',  line = 3 },  --3
        { fileName = 'fn',  line = 3 },  --4
        { fileName = 'fn2', line = 1 },  --5
        { fileName = 'fn2', line = 2 },  --6
        { fileName = 'fn',  line = 7 },  --7
        { fileName = 'fn',  line = 8 }}} --8
end

function M.test:tearDown()
    _lineMap = {}
    self.errors = nil
end

function M.test:setCurrentChunkName(ut)
    ut:succeeds(self.errors.setCurrentChunkName, 'Hallaien')
    ut:equals(currentChunkName, 'Hallaien')
    ut:succeeds(self.errors.setCurrentChunkName, 'Eg likar banan')
    ut:equals(currentChunkName, 'Eg likar banan')
end

function M.test:addToLineMap(ut)
    self.errors.setCurrentChunkName'chunk'
    ut:succeeds(self.errors.addToLineMap, 9, 10, 'fn3')
    ut:equals(_lineMap.chunk[10].line, 9)
    ut:equals(_lineMap.chunk[10].fileName, 'fn3')
    ut:succeeds(self.errors.addToLineMap, 10, 1, 'fn')
    ut:equals(_lineMap.chunk[1].line, 1)
    ut:equals(_lineMap.chunk[1].fileName, 'fn')
    self.errors.setCurrentChunkName'chunk2'
    ut:succeeds(self.errors.addToLineMap, 9, 10, 'fn3')
    ut:equals(_lineMap.chunk2[10].line, 9)
    ut:equals(_lineMap.chunk2[10].fileName, 'fn3')
    ut:succeeds(self.errors.addToLineMap, 10, 1, 'fn')
    ut:equals(_lineMap.chunk2[1].line, 10)
    ut:equals(_lineMap.chunk2[1].fileName, 'fn')
end

function M.test:searchForLineMatch(ut)
    self.errors.setCurrentChunkName'chunk'
    self.errors.addToLineMap(14, 14, 'fn')
    self.errors.addToLineMap(12, 12, 'fn')
    self.errors.addToLineMap(15, 15, 'fn')
    local line = ut:succeeds(searchForLineMatch, 9, 'chunk')
    ut:equals(line, 8)
    line = ut:succeeds(searchForLineMatch, 2, 'chunk')
    ut:equals(line, 3)
    line = ut:succeeds(searchForLineMatch, 11, 'chunk')
    ut:equals(line, 12)
    line = ut:succeeds(searchForLineMatch, 10, 'chunk')
    ut:equals(line, 8)
    line = ut:succeeds(searchForLineMatch, 13, 'chunk')
    ut:equals(line, 14)
    line = ut:succeeds(searchForLineMatch, 100, 'chunk')
    ut:equals(line, 15)
end

function M.test:getNameAndLine(ut)
    local name, line = ut:succeeds(getNameAndLine, "chunk:1:Some kind of error", 'chunk')
    ut:equals(name, "fn")
    ut:equals(line, 1)
    name, line = ut:succeeds(getNameAndLine, "chunk:12:Some kind of error", 'chunk')
    ut:equals(name, "fn")
    ut:equals(line, 8)
    name, line = ut:succeeds(getNameAndLine, "chunk:5:Some kind of error", 'chunk')
    ut:equals(name, "fn2")
    ut:equals(line, 1)
end

function M.test:getErrorMessage(ut)
    local errmess = ut:succeeds(getErrorMessage, [[./mad/lang/errors.lua:184: '=' expected near '+'
stack traceback:
	[C]: at 0x004504e0
	[C]: in function 'require'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
    ut:equals(errmess, [['=' expected near '+'
stack traceback:
	[C]: at 0x004504e0
	[C]: in function 'require'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
    errmess = ut:succeeds(getErrorMessage, [[:213:name]])
    ut:equals(errmess, [[name]])
end

function M.test:getStackTraceBack(ut)
    local stb = ut:succeeds(getStackTraceBack, [[./mad/lang/errors.lua:184: '=' expected near '+'
stack traceback:
	stuffhanppfewpfkw
	fewf
	hrthrst43t
	h
	grte
	
	few
	[C]: in function 'xpcall'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
    ut:equals(stb, [[stuffhanppfewpfkw
	fewf
	hrthrst43t
	h
	grte
	
	few
]])
    stb = ut:succeeds(getStackTraceBack, [[./mad/lang/errors.lua:184: '=' expected near '+'
stack traceback:
	[C]: at 0x004504e0
	[C]: in function 'require'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
    ut:equals(stb, nil)
    stb = ut:succeeds(getStackTraceBack, [[:213:name]])
    ut:equals(stb, nil)
end

function M.test:createStackTable(ut)
    local stbl = ut:succeeds(createStackTable, [[chunk:1:error
chunk:2:error2
chunk:5:error5
chunk:9:error9
]])
    ut:equals(stbl, { "\tfn:1:error", "\tfn:2:error2", "\tfn2:1:error5", "\tfn:8:error9" })
end

function M.test:createStackErrorMessage(ut)
    local st = ut:succeeds(createStackErrorMessage, { '1','2','3','4','5' })
    ut:equals(st, [[

stack traceback:
1
2
3
4
5]])
end

function M.test:getChunkName(ut)
    local ch = ut:succeeds(getChunkName,[[./mad/lang/errors.lua:184: '=' expected near '+']])
	ut:equals(ch, "./mad/lang/errors.lua")
    ch = ut:succeeds(getChunkName,[[./mad/lang/errors.lua:184: '=' expected near '+'
stack traceback:
	[C]: at 0x004504e0
	[C]: in function 'require'
	./mad/utest/luaUnit.lua:128: in function 'runTestModuleByName'
	./mad/utest/luaUnit.lua:165: in function 'testTable'
	./mad/utest/luaUnit.lua:181: in function 'run'
	./mad/tester.lua:85: in function <./mad/tester.lua:75>
	./mad-e:12: in main chunk
	[C]: at 0x00404250]])
	ut:equals(ch, "./mad/lang/errors.lua")
end

function M.test:translateLuaErrToMadErr(ut)
    local transmess = ut:succeeds(translateLuaErrToMadErr, "chunk:1:error1", 
[[stack traceback:
	chunk:2:error2
	chunk:5:error5
	chunk:10:error10
	[C]: in function 'xpcall'
	]])
    ut:equals(transmess, [[fn:1: error1
stack traceback:
	fn:2:error2
	fn2:1:error5
	fn:8:error10]])
end

function M.test:handleError (ut)
    local transmess = ut:succeeds(self.errors.handleError, "chunk:1:error1", 
[[stack traceback:
	chunk:2:error2
	chunk:5:error5
	chunk:10:error10
	[C]: in function 'xpcall'
	]])
    ut:equals(transmess, [[fn:1: error1
stack traceback:
	fn:2:error2
	fn2:1:error5
	fn:8:error10]])
end


-- end ------------------------------------------------------------------------
return M
