local M  = { help = {}, test = {} }

-- MAD -------------------------------------------------------------------------

M.help.self = [[
NAME
  mad.lang.errors
  
SYNOPSIS
  local errorHandler = require "mad.lang.errors"()
  errorHandler.setCurrentChunkName(chunkname)
  errorHandler:addToLineMap(astNode.line, generator.writtenLine, chunkName)
  errorHandler:handleError(errmess, trace)
  
DESCRIPTION
  Maps lines from the generated lines to the input lines, making errormessages
  report lines on the place where they are written by the user, instead of 
  where they are generated by Lua.
  
  local errorHandler = require "mad.lang.errors"()
    -Creates a new instance
  errorHandler.setCurrentChunkName(chunkname)
    -Sets the chunkname to be used by the parser
  errorHandler:addToLineMap(astNode.line, generator.writtenLine, chunkName)
    -Adds a line to the map
  errorHandler:handleError(errmess, trace)
    -Makes an error report to the correct lines in the original files.
    
RETURN VALUES
  None
  
SEE ALSO
  None
]]

-- require ---------------------------------------------------------------------

-- metamethods ----------------------------------------------------------------
local mt = {}; setmetatable(M, mt)
local new
mt.__call = function (...)
	return new(...)
end

-- modules ---------------------------------------------------------------------

local setCurrentChunkName = function(self, name)
	self.currentChunkName = name
	if not self._lineMap[self.currentChunkName] then
		self._lineMap[self.currentChunkName] = {}
	end
end

local addToLineMap = function(self, lineIn, lineOut, fileName)
	if not self._lineMap[self.currentChunkName][lineOut] then
		self._lineMap[self.currentChunkName][lineOut] = {}
	end
	self._lineMap[self.currentChunkName][lineOut].fileName = fileName
	if not self._lineMap[self.currentChunkName][lineOut].start or lineIn and self._lineMap[self.currentChunkName][lineOut].start > lineIn then
		self._lineMap[self.currentChunkName][lineOut].start = lineIn
	end
end

local function searchForLineMatch(self, line, chunkName)
	if self._lineMap[chunkName][line+1] then
		line = line+1
	else
		while line > 1 and not self._lineMap[chunkName][line] do
			line = line - 1
		end
	end
	return line
end

local function getNameAndLine(self, err, chunkName)
	local line = tonumber(string.match(err, ":(%d+):"))
	if not self._lineMap[chunkName][line] then
		line = searchForLineMatch(self, line, chunkName)
	end
	local name = self._lineMap[chunkName][line].fileName
	local realLine = self._lineMap[chunkName][line].start
	return name, realLine
end

local function getErrorMessage(err)
	return string.match(err,":%d+:%s*(.+)")
end

local function getStackTraceBack(err)
	return string.match(err, ".*stack traceback:%s*(.*)%s%[C%]: in function 'xpcall'")
end

local function createStackTable(self, stack)
	local stacktable = {}
	for s in string.gmatch(stack,"(.-)\n%s*") do
	    local chunkName = string.match(s,"(.-):%d+:")
		local name, line = getNameAndLine(self, s, chunkName)
		stacktable[#stacktable+1] = "\t"..name..":"..line..":"..string.match(s,":%d+:(.*)")
	end
	return stacktable
end

local function createStackErrorMessage(stacktable)
	local errmess = "\nstack traceback:"
	for i,v in pairs(stacktable) do
		errmess = errmess.."\n"..v
	end
	return errmess
end

local function getChunkName(err)
	return string.match(err, "(.*):%d+:")
end

local function translateLuaErrToMadErr(self, err, trace)
	local chunkName = getChunkName(err)
	local name, realLine = getNameAndLine(self, err, chunkName)
	local errmess = getErrorMessage(err)
	errmess = name..":"..realLine..": "..errmess
	local stack = getStackTraceBack(trace)
	local stacktable = createStackTable(self, stack)
	errmess = errmess..createStackErrorMessage(stacktable)
	return errmess
end

local function handleError (self, err, trace)
	local errmess = translateLuaErrToMadErr(self, err, trace)
	return errmess
end

new = function (_, ...)
	local self = {
		_lineMap = {},
		currentChunkName,
		setCurrentChunkName = setCurrentChunkName,
		addToLineMap = addToLineMap,
		handleError = handleError
	}
	return self
end

-- end ------------------------------------------------------------------------
return M
