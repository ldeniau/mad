#ifndef TPSA_FUN_TEMPLATE
#define TPSA_FUN_TEMPLATE

#define T struct tpsa
#define D struct tpsa_desc

// #define TRACE

// --- LOCAL FUNCTIONS --------------------------------------------------------
static inline void
fixed_point_iteration(const T *a, T *c, int iter, num_t expansion_coef[iter+1])
{
#ifdef TRACE
  printf("fixed_point\n");
#endif
  assert(a && c && expansion_coef);
  ensure(a->desc == c->desc);

  mad_tpsa_setConst(c,expansion_coef[0]);

  T *pow = mad_tpsa_new(c),
    *acp = mad_tpsa_new(c),
    *tmp = mad_tpsa_new(c);
  mad_tpsa_setConst(pow,1.0);
  mad_tpsa_copy(a,acp);
  mad_tpsa_seti(acp,0,0.0);

  for (int i = 1; i <= iter; ++i) {
    mad_tpsa_mul(acp,pow,tmp);
    mad_tpsa_copy(tmp,pow);
    scale_and_accum(expansion_coef[i],pow,c);
  }

  mad_tpsa_del(pow);
  mad_tpsa_del(acp);
  mad_tpsa_del(tmp);
}

static inline void
sincos_fixed_point(const T *a, T *s, T *c, ord_t smo, num_t sin_coef[smo+1], ord_t cmo, num_t cos_coef[cmo+1])
{
  assert(a && s && c && sin_coef && cos_coef);

  mad_tpsa_setConst(s,sin_coef[0]);
  mad_tpsa_setConst(c,cos_coef[0]);

  T *pow = mad_tpsa_new(a),
    *acp = mad_tpsa_new(a),
    *tmp = mad_tpsa_new(a);
  mad_tpsa_setConst(pow,1.0);
  mad_tpsa_copy(a,acp);
  mad_tpsa_seti(acp,0,0.0);

  int max_iter = imax(smo,cmo);
  for (int i = 1; i <= max_iter; ++i) {
    mad_tpsa_mul(acp,pow,tmp);
    mad_tpsa_copy(tmp,pow);

    if (i <= smo) scale_and_accum(sin_coef[i],pow,s);
    if (i <= cmo) scale_and_accum(cos_coef[i],pow,c);
  }
  mad_tpsa_del(pow);
  mad_tpsa_del(acp);
  mad_tpsa_del(tmp);
}

// --- PUBLIC FUNCTIONS -------------------------------------------------------
void
mad_tpsa_inv(const T *a, T *c)
{
// 1/(A0+P) = 1/A0*(1-(P/A0)+(P/A0)**2-...)
#ifdef TRACE
  printf("tpsa_inv\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(a->coef[0] != 0);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1], a0 = a->coef[0];
  expansion_coef[0] = 1.0 / a0;
  for (int o = 1; o <= to; ++o)
    expansion_coef[o] = -expansion_coef[o-1] / a0;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_sqrt(const T *a, T *c)
{
// SQRT(A0+P) = SQRT(A0)*(1+1/2(P/A0)-1/8*(P/A0)**2+...)
#ifdef TRACE
  printf("tpsa_sqrt\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(a->coef[0] > 0);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1], a0 = a->coef[0];
  expansion_coef[0] = sqrt(a0);
  for (int o = 1; o <= to; ++o)
    expansion_coef[o] = -expansion_coef[o-1] / a0 / (2.0*o) * (2.0*o-3);

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_isrt(const T *a, T *c)
{
// 1/SQRT(A0+P) = 1/SQRT(A0)*(1-1/2(P/A0)+3/8*(P/A0)**2-...)
#ifdef TRACE
  printf("tpsa_isrt\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(a->coef[0] > 0);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1], a0 = a->coef[0];
  expansion_coef[0] = 1.0/sqrt(a0);
  for (int o = 1; o <= to; ++o)
    expansion_coef[o] = -expansion_coef[o-1] / a0 / (2.0*o) * (2.0*o-1);

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_exp(const T *a, T *c)
{
// EXP(A0+P) = EXP(A0)*(1+P+P**2/2!+...)
#ifdef TRACE
  printf("tpsa_exp\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1], a0 = a->coef[0];
  expansion_coef[0] = exp(a0);
  for (int o = 1; o <= to; ++o)
    expansion_coef[o] = expansion_coef[o-1] / o;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_log(const T *a, T *c)
{
// LOG(A0+P) = LOG(A0) + (P/A0) - 1/2*(P/A0)**2 + 1/3*(P/A0)**3 - ...)
#ifdef TRACE
  printf("tpsa_log\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(a->coef[0] > 0);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1], a0 = a->coef[0];
  expansion_coef[0] = log(a0);
  expansion_coef[1] = 1/a0;
  for (int o = 2; o <= to; ++o)
    expansion_coef[o] = -expansion_coef[o-1] / a0 / o * (o-1);

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_sin(const T *a, T *c)
{
// SIN(A0+P) = SIN(A0)*(1-P**2/2!+P**4/4!+...) + COS(A0)*(P-P**3/3!+P**5/5!+...)
#ifdef TRACE
  printf("tpsa_sin\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1], a0 = a->coef[0];
  expansion_coef[0] = sin(a0);
  expansion_coef[1] = cos(a0);
  for (int o = 2; o <= to; ++o)
    expansion_coef[o] = -expansion_coef[o-2] / (o*(o-1));

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_cos(const T *a, T *c)
{
// COS(A0+P) = COS(A0)*(1-P**2/2!+P**4/4!+...) - SIN(A0)*(P-P**3/3!+P**5/5!+...)
#ifdef TRACE
  printf("tpsa_cos\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1], a0 = a->coef[0];
  expansion_coef[0] =  cos(a0);
  expansion_coef[1] = -sin(a0);
  for (int o = 2; o <= to; ++o)
    expansion_coef[o] = -expansion_coef[o-2] / (o*(o-1));

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_sincos(const T *a, T *s, T *c)
{
#ifdef TRACE
  printf("tpsa_sincos\n");
#endif
  assert(a && s && c);
  ensure(a->desc == s->desc && a->desc == c->desc);

  ord_t sto = min_ord2(s->mo,a->desc->trunc),
        cto = min_ord2(c->mo,a->desc->trunc);

  // ord 0, 1
  num_t sin_coef[sto+1], cos_coef[cto+1];
  sin_coef[0] =  sin(a->coef[0]);
  cos_coef[0] =  cos(a->coef[0]);
  sin_coef[1] =  cos_coef[0];
  cos_coef[1] = -sin_coef[0];

  // ords 2..to
  for (int o = 2; o <= sto; ++o )
    sin_coef[o] = -sin_coef[o-2] / (o*(o-1));
  for (int o = 2; o <= cto; ++o )
    cos_coef[o] = -cos_coef[o-2] / (o*(o-1));

  sincos_fixed_point(a,s,c, sto,sin_coef, cto,cos_coef);
}

void
mad_tpsa_sinh(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_sinh\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1], a0 = a->coef[0];
  expansion_coef[0] = sinh(a0);
  expansion_coef[1] = cosh(a0);
  for (int o = 2; o <= to; ++o)
    expansion_coef[o] = expansion_coef[o-2] / (o*(o-1));

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_cosh(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_cosh\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1], a0 = a->coef[0];
  expansion_coef[0] = cosh(a0);
  expansion_coef[1] = sinh(a0);
  for (int o = 2; o <= to; ++o)
    expansion_coef[o] = expansion_coef[o-2] / (o*(o-1));

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_sincosh(const T *a, T *sh, T *ch)
{
#ifdef TRACE
  printf("tpsa_sincos\n");
#endif
  assert(a && sh && ch);
  ensure(a->desc == sh->desc && a->desc == ch->desc);

  ord_t sto = min_ord2(sh->mo,a->desc->trunc),
        cto = min_ord2(ch->mo,a->desc->trunc);

  // ord 0, 1
  num_t sin_coef[sto+1], cos_coef[cto+1];
  sin_coef[0] = sinh(a->coef[0]);
  cos_coef[0] = cosh(a->coef[0]);
  sin_coef[1] = cos_coef[0];
  cos_coef[1] = sin_coef[0];

  // ords 2..to
  for (int o = 2; o <= sto; ++o )
    sin_coef[o] = sin_coef[o-2] / (o*(o-1));
  for (int o = 2; o <= cto; ++o )
    cos_coef[o] = cos_coef[o-2] / (o*(o-1));

  sincos_fixed_point(a,sh,ch, sto,sin_coef, cto,cos_coef);
}

void
mad_tpsa_sirx(const T *a, T *c)
{
// SIN(SQRT(P))/SQRT(P) = 1 - P/3! + P**2/5! - P**3/7! + ...
#ifdef TRACE
  printf("tpsa_sirx\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(a->coef[0] == 0);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1];
  expansion_coef[0] = 1.0;
  for (int o = 1; o <= to; ++o)
    expansion_coef[o] = -expansion_coef[o-1] / (2*o * (2*o+1));

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_corx(const T *a, T *c)
{
// COS(SQRT(P)) = 1 - P/2! + P**2/4! - P**3/6! + ...
#ifdef TRACE
  printf("tpsa_corx\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(a->coef[0] == 0);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1];
  expansion_coef[0] = 1.0;
  for (int o = 1; o <= to; ++o)
    expansion_coef[o] = -expansion_coef[o-1] / (2*o * (2*o-1));

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_sidx(const T *a, T *c)
{
// SIN(P)/P = 1 - P**2/3! + P**4/5! - P**6/7! + ...
#ifdef TRACE
  printf("tpsa_sidx\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(a->coef[0] == 0);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  num_t expansion_coef[to+1];
  expansion_coef[0] = 1.0;
  expansion_coef[1] = 0.0;
  for (int o = 2; o <= to; ++o)
    expansion_coef[o] = -expansion_coef[o-2] / (o * (o+1));

  fixed_point_iteration(a,c,to,expansion_coef);
}

// --- The following functions are manually expanded up to order 5

enum { MANUAL_EXPANSION_ORD = 5 };

void
mad_tpsa_tan(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_tan\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(fabs(cos(a->coef[0])) > 1e-10);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0];
  num_t sa = sin(a0), ca = cos(a0);
  expansion_coef[0] =  sa                     / ca;
  expansion_coef[1] =   1                     / ca/ca;
  expansion_coef[2] =  sa                     / ca/ca/ca;
  expansion_coef[3] =  (  ca*ca + 3*sa*sa)    / ca/ca/ca/ca       /3;
  expansion_coef[4] =  (2*sa    +   sa*sa*sa) / ca/ca/ca/ca/ca    /3;
  expansion_coef[5] =  (2*ca*ca + 3*ca*ca*sa*sa + 10*sa*sa + 5*sa*sa*sa*sa)
                                              / ca/ca/ca/ca/ca/ca /15;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_cot(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_cot\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(fabs(sin(a->coef[0])) > 1e-10);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0];
  num_t sa = sin(a0), ca = cos(a0);
  expansion_coef[0] = ca                  / sa;
  expansion_coef[1] = -1                  / sa/sa;
  expansion_coef[2] = ca                  / sa/sa/sa;
  expansion_coef[3] = -(sa*sa +  3*ca*ca) / sa/sa/sa/sa       /3;
  expansion_coef[4] =  (2*ca  + ca*ca*ca) / sa/sa/sa/sa/sa    /3;
  expansion_coef[5] = -(2*sa*sa + 3*sa*sa*ca*ca + 10*ca*ca + 5*ca*ca*ca*ca)
                                          / sa/sa/sa/sa/sa/sa /15;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_asin(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_asin\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(fabs(a->coef[0]) < 1);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0], xcf1;
  expansion_coef[0] = asin(a0);
               xcf1 = 1/sqrt(1 - a0*a0);
  expansion_coef[1] =                        xcf1;
  expansion_coef[2] =            a0        * xcf1*xcf1*xcf1                     / 2;
  expansion_coef[3] = (1    +  2*a0*a0   ) * xcf1*xcf1*xcf1*xcf1*xcf1           / 6;
  expansion_coef[4] = (3*a0 +  2*a0*a0*a0) * xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1 / 8;
  expansion_coef[5] = (3    + 24*a0*a0 + 8*a0*a0*a0*a0)
                      *            xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1 / 40;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_acos(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_acos\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(fabs(a->coef[0]) < 1);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0], xcf1;
  expansion_coef[0] = acos(a0);
               xcf1 =  1/sqrt(1 - a0*a0);
  expansion_coef[1] = -                       xcf1;
  expansion_coef[2] = -           a0        * xcf1*xcf1*xcf1                     / 2;
  expansion_coef[3] = -(1    +  2*a0*a0   ) * xcf1*xcf1*xcf1*xcf1*xcf1           / 6;
  expansion_coef[4] = -(3*a0 +  2*a0*a0*a0) * xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1 / 8;
  expansion_coef[5] = -(3    + 24*a0*a0 + 8*a0*a0*a0*a0)
                      *             xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1 / 40;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_atan(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_atan\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0], xcf1;
  expansion_coef[0] = atan(a0);
               xcf1 = 1 / (1 +  a0*a0);
  expansion_coef[1] =                                    xcf1;
  expansion_coef[2] = -a0                              * xcf1*xcf1;
  expansion_coef[3] = -(1.0/3 - a0*a0)                 * xcf1*xcf1*xcf1;
  expansion_coef[4] =  (a0    - a0*a0*a0)              * xcf1*xcf1*xcf1*xcf1;
  expansion_coef[5] =  (1.0/5 + a0*a0*a0*a0 - 2*a0*a0) * xcf1*xcf1*xcf1*xcf1*xcf1;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_acot(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_acot\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0], xcf1;
  expansion_coef[0] = 2*atan(1) - atan(a0);
               xcf1 = 1/(1 + a0*a0);
  expansion_coef[1] = -                                  xcf1;
  expansion_coef[2] =           a0                     * xcf1*xcf1;
  expansion_coef[3] =  (1.0/3 - a0*a0)                 * xcf1*xcf1*xcf1;
  expansion_coef[4] = -(a0    - a0*a0*a0)              * xcf1*xcf1*xcf1*xcf1;
  expansion_coef[5] = -(1.0/5 + a0*a0*a0*a0 - 2*a0*a0) * xcf1*xcf1*xcf1*xcf1*xcf1;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_tanh(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_tanh\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0];
  num_t sa = sinh(a0), ca = cosh(a0);
  expansion_coef[0] = sa                  / ca;
  expansion_coef[1] =  1                  / ca/ca;
  expansion_coef[2] = -sa                 / ca/ca/ca;
  expansion_coef[3] = (-ca*ca +  3*sa*sa) / ca/ca/ca/ca       /3;
  expansion_coef[4] = (2*sa   - sa*sa*sa) / ca/ca/ca/ca/ca    /3;
  expansion_coef[5] = (2*ca*ca - 3*ca*ca*sa*sa - 10*sa*sa + 5*sa*sa*sa*sa)
                                          / ca/ca/ca/ca/ca/ca /15;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_coth(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_coth\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(fabs(sinh(a->coef[0])) > 1e-10);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0];
  num_t sa = sinh(a0), ca = cosh(a0);
  expansion_coef[0] = ca                      / sa;
  expansion_coef[1] = -1                      / sa/sa;
  expansion_coef[2] = ca                      / sa/sa/sa;
  expansion_coef[3] = (sa*sa    - 3*ca*ca)    / sa/sa/sa/sa       /3;
  expansion_coef[4] = ( 2*ca    +   ca*ca*ca) / sa/sa/sa/sa/sa    /3;
  expansion_coef[5] = ( 2*sa*sa + 3*sa*sa*ca*ca - 10*ca*ca - 5*ca*ca*ca*ca)
                                              / sa/sa/sa/sa/sa/sa /15;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_asinh(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_asinh\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0], xcf1;
  expansion_coef[0] = asinh(a0);
               xcf1 = 1/sqrt(1 + a0*a0);
  expansion_coef[1] =                        xcf1;
  expansion_coef[2] = -          a0        * xcf1*xcf1*xcf1                     / 2;
  expansion_coef[3] = (-1   +  2*a0*a0   ) * xcf1*xcf1*xcf1*xcf1*xcf1           / 6;
  expansion_coef[4] = (3*a0 -  2*a0*a0*a0) * xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1 / 8;
  expansion_coef[5] = (3    - 24*a0*a0 + 8*a0*a0*a0*a0)
                      *           xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1  / 40;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_acosh(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_acosh\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(a->coef[0] > 1);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0], xcf1;
  expansion_coef[0] = acosh(a0);
               xcf1 = -1/sqrt(1 - a0*a0);
  expansion_coef[1] =                        xcf1;
  expansion_coef[2] = -        a0          * xcf1*xcf1*xcf1                     / 2;
  expansion_coef[3] = (1     + 2*a0*a0   ) * xcf1*xcf1*xcf1*xcf1*xcf1           / 6;
  expansion_coef[4] = (-3*a0 - 2*a0*a0*a0) * xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1 / 8;
  expansion_coef[5] = (3     + 24*a0*a0 + 8*a0*a0*a0*a0)
                      *            xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1*xcf1 / 40;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_atanh(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_atanh\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(fabs(a->coef[0]) < 1);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0], xcf1;
  expansion_coef[0] = atanh(a0);
               xcf1 = 1 / (1 - a0*a0);
  expansion_coef[1] =                                   xcf1;
  expansion_coef[2] = a0                              * xcf1*xcf1;
  expansion_coef[3] = (1.0/3 + a0*a0)                 * xcf1*xcf1*xcf1;
  expansion_coef[4] = (a0    + a0*a0*a0)              * xcf1*xcf1*xcf1*xcf1;
  expansion_coef[5] = (1.0/5 + a0*a0*a0*a0 + 2*a0*a0) * xcf1*xcf1*xcf1*xcf1*xcf1;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_acoth(const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_acoth\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  ensure(fabs(a->coef[0]) > 1);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0], xcf1;
  expansion_coef[0] = atanh(1/a0);
               xcf1 = 1 / (-1 + a0*a0);
  expansion_coef[1] = -                                  xcf1;
  expansion_coef[2] =   a0                             * xcf1*xcf1;
  expansion_coef[3] = (-1.0/3 - a0*a0)                 * xcf1*xcf1*xcf1;
  expansion_coef[4] = (a0     + a0*a0*a0)              * xcf1*xcf1*xcf1*xcf1;
  expansion_coef[5] = (-1.0/5 - a0*a0*a0*a0 - 2*a0*a0) * xcf1*xcf1*xcf1*xcf1*xcf1;

  fixed_point_iteration(a,c,to,expansion_coef);
}

void
mad_tpsa_erf(const T *a, T *c)
{
  // ERF(X) is the integral from 0 to x from [2/sqrt(PI) * exp(-x*x)]
#ifdef TRACE
  printf("tpsa_erf\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  ord_t to = min_ord2(c->mo,a->desc->trunc);
  ensure(to <= 5);

  num_t expansion_coef[MANUAL_EXPANSION_ORD+1], a0 = a->coef[0];
  // coeff from Berz's TPSALib
  num_t e1 = exp(-a0*a0),
        a1 =   .254829592,
        a2 = - .284496736,
        a3 =  1.421413741,
        a4 = -1.453152027,
        a5 =  1.061405429,
        p  =   .3275911,
        rpi4 = sqrt(atan(1.0)),
        t  = 1 / (1 + p*a0),
        e2 = 1 - t*(a1+t*(a2+t*(a3+t*(a4+t*a5))))*e1;
  expansion_coef[0] = e2;
  expansion_coef[1] =                                        e1 / rpi4;
  expansion_coef[2] = -                                   a0*e1 / rpi4;
  expansion_coef[3] = (-1             +  2*a0*a0)      /   3*e1 / rpi4;
  expansion_coef[4] = (12*a0          -  8*a0*a0*a0)   /  24*e1 / rpi4;
  expansion_coef[5] = (16*a0*a0*a0*a0 - 48*a0*a0 + 12) / 120*e1 / rpi4;

  fixed_point_iteration(a,c,to,expansion_coef);
}

#undef T
#undef D
#endif
