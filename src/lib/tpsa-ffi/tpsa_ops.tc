#ifndef TPSA_OPS_TEMPLATE
#define TPSA_OPS_TEMPLATE

#define T struct tpsa
#define D struct tpsa_desc

// #define TRACE

// --- LOCAL FUNCTIONS --------------------------------------------------------

#ifdef _OPENMP
#include <omp.h>
// for debugging Thread ID
#define _GNU_SOURCE
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <time.h>
#endif

static const int chunksize[2] = {1024,1024};

static inline int
hpoly_triang_mul(const num_t *ca, const num_t *cb, num_t *cc, const idx_t const* l, int oa, int pi[])
{
#ifdef TRACE
  printf("triang_mul oa=%d ob=%d\n", oa, oa);
#endif
  int iao = pi[oa], ibo = pi[oa];  // offsets for shifting to 0
  int l_size = (pi[oa+1]-pi[oa]) * (pi[oa+1]-pi[oa] + 1) / 2, oc = oa + oa;
  (void)oc; (void)l_size;  // avoid warning when compiling without assert

  // asymm: c[2 2] = a[2 0]*b[0 2] + a[0 2]*b[2 0]
  for (idx_t ib = pi[oa]; ib < pi[oa+1]; ib++)
  for (idx_t ia = ib + 1; ia < pi[oa+1]; ia++) {
    int il = hpoly_idx_triang(ib-ibo, ia-iao);
    assert(0 <= il && il < l_size);

    int ic = l[il];
    if (ic >= 0) {
      assert(pi[oc] <= ic && ic < pi[oc+1]);
      cc[ic] = cc[ic] + ca[ia]*cb[ib] + ca[ib]*cb[ia];
    }
  }

  // symm: c[2 2] = a[1 1] * b[1 1]
  for (int ia=pi[oa]; ia < pi[oa+1]; ia++) {
    int il = hpoly_idx_triang(ia-iao, ia-iao);
    assert(0 <= il && il < l_size);

    int ic = l[il];
    if (ic >= 0) {
      assert(pi[oc] <= ic && ic < pi[oc+1]);
      cc[ic] = cc[ic] + ca[ia]*cb[ia];
    }
  }
  return (pi[oa+1]-pi[oa]) * (pi[oa+1]-pi[oa]);
}

static inline void
idx_and_sym_mul(int iab_sum, int ilb, int ia_size, int ib_size,
                const num_t *ca, const num_t *cb, num_t *cc, const idx_t* l, int oa, int ob, int pi[])
{
  int l_size  = ia_size*ib_size, oc = oa+ob;
  (void)oc; (void)l_size;  // avoid warning when compiling without assert

  int ila = iab_sum - ilb;
  int il = hpoly_idx_rect(ilb,ila,ia_size);
  assert(0 <= il && il < l_size);
  idx_t ia = pi[oa] + ila;
  idx_t ib = pi[ob] + ilb;
  assert(pi[oa] <= ia && ia < pi[oa+1]);
  assert(pi[ob] <= ib && ib < pi[ob+1]);

  int ic = l[il];
  if (ic >= 0) {
    assert(pi[oc] <= ic && ic < pi[oc+1]);
    cc[ic] = cc[ic] + ca[ia]*cb[ib] + ca[ib]*cb[ia];
  }
}

static inline int
hpoly_sym_mul(const num_t *ca, const num_t *cb, num_t *cc, const idx_t* l, int oa, int ob, int pi[])
{
#ifdef TRACE
  printf("sym_mul oa=%d ob=%d \n", oa, ob);
#endif
  int ia_size = pi[oa+1]-pi[oa], ib_size = pi[ob+1]-pi[ob];

  int iab_sum = 0;
  for ( ; iab_sum < ib_size - 1; ++iab_sum)
    for (int ilb = 0; ilb < iab_sum; ++ilb)
      idx_and_sym_mul(iab_sum,ilb, ia_size,ib_size, ca,cb,cc,l,oa,ob,pi);

  for ( ; iab_sum < ia_size; ++iab_sum)
    for (int ilb = 0; ilb < ib_size; ++ilb)
      idx_and_sym_mul(iab_sum,ilb, ia_size,ib_size, ca,cb,cc,l,oa,ob,pi);

  for ( ; iab_sum < ia_size+ib_size - 1; ++iab_sum)
    for (int ilb = iab_sum-ia_size + 1; ilb < ib_size; ++ilb)
      idx_and_sym_mul(iab_sum,ilb, ia_size,ib_size, ca,cb,cc,l,oa,ob,pi);


  // oa > ob so longer loop is inside
  // for (idx_t ib=pi[ob]; ib < pi[ob+1]; ib++)
  // for (idx_t ia=pi[oa]; ia < pi[oa+1]; ia++) {
  //   int il = hpoly_idx_rect(ib-ibo, ia-iao, ia_size);
  //   assert(0 <= il && il < l_size);

  //   int ic = l[il];
  //   // if (ic >= 0) {
  //   //   assert(pi[oc] <= ic && ic < pi[oc+1]);
  //   //   cc[ic] = cc[ic] + ca[ia]*cb[ib] + ca[ib]*cb[ia];
  //   // }
  //   assert(pi[oc] <= ic && ic < pi[oc+1]);
  //   cc[ic] = cc[ic] + ca[ia]*cb[ib] + ca[ib]*cb[ia];
  // }
  return (pi[oa+1]-pi[oa]) * (pi[ob+1]-pi[ob]) * 2;
}

static inline int
hpoly_asym_mul(const num_t *ca, const num_t *cb, num_t *cc, const idx_t* l, int oa, int ob, int pi[])
{
#ifdef TRACE
  printf("asym_mul oa=%d ob=%d \n", oa, ob);
#endif
  int iao = pi[oa], ibo = pi[ob];  // offsets for shifting to 0
  int ia_size = pi[oa+1]-pi[oa], ib_size = pi[ob+1]-pi[ob];
  int l_size  = ia_size*ib_size, oc = oa+ob;
  (void)oc; (void)l_size;  // avoid warning when compiling without assert

  // oa > ob so longer loop is inside
  for (idx_t ib=pi[ob]; ib < pi[ob+1]; ib++)
  for (idx_t ia=pi[oa]; ia < pi[oa+1]; ia++) {
    int il = hpoly_idx_rect(ib-ibo, ia-iao, ia_size);
    assert(0 <= il && il < l_size);

    int ic = l[il];
    if (ic >= 0) {
      assert(pi[oc] <= ic && ic < pi[oc+1]);
      cc[ic] = cc[ic] + ca[ia]*cb[ib];
    }
  }
  return (pi[oa+1]-pi[oa]) * (pi[ob+1]-pi[ob]);
}

#ifndef _OPENMP
static inline void
hpoly_mul(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("poly_mul\n");
#endif
  D *dc = c->desc;
  const idx_t *l = NULL;
  int *ps = dc->hpoly_To_idx, hod = dc->mo/2;
  const num_t *ca = a->coef,  *cb = b->coef;
        num_t *cc = c->coef;
        bit_t nza = a->nz  ,  nzb = b->nz;

  int chunksize[2] = {2,3};

  for (int oc=c->mo; oc >= 2; oc--) {
    for (int j=1; j <= (oc-1)/2; ++j) {
      int oa = oc-j, ob = j;            // oa > ob >= 1
      l = dc->L[oa*hod + ob];
      assert(l);

      if (bget(nza,oa) && bget(nzb,ob) && bget(nza,ob) && bget(nzb,oa)) {
        hpoly_sym_mul(ca,cb,cc, l,chunksize, oa,ob,ps);
        c->nz = bset(c->nz,oc);
      }
      else if (bget(nza,oa) && bget(nzb,ob)) {
        hpoly_asym_mul(ca,cb,cc, l, oa,ob,ps);
        c->nz = bset(c->nz,oc);
      }
      else if (bget(nza,ob) && bget(nzb,oa)) {
        hpoly_asym_mul(cb,ca,cc, l, oa,ob,ps);
        c->nz = bset(c->nz,oc);
      }
    }

    if (! (oc & 1)) {  // even oc, triang matrix
      int hoc = oc/2;
      l = dc->L[hoc*hod + hoc];
      assert(l);
      if (bget(nza,hoc) && bget(nzb,hoc) ) {
        hpoly_triang_mul(ca,cb,cc, l, hoc,ps);
        c->nz = bset(c->nz,oc);
      }
    }
  }
}
#else  // OPENMP

static inline void
hpoly_mul(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("poly_mul_parallel\n");
#endif
  D *dc = c->desc;
  // const idx_t *l = NULL;
  int *ps = dc->hpoly_To_idx, hod = dc->mo/2;
  const num_t *ca = a->coef,  *cb = b->coef;
        num_t *cc = c->coef;
        bit_t nza = a->nz  ,  nzb = b->nz;

  static const int nb_threads = 4;
  bit_t c_nzs[nb_threads];
  for (int t = 0; t < nb_threads; ++t)
    c_nzs[t] = c->nz;

  static const int ocs[4][20] = {
              { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, },
              { 19, 17 },
              { 20, },
              { 0 },
              };
  // int ocs[4][20] = { { 2, 5 }, { 3 }, { 4 }, { 0 }, };
  int ops[c->mo+1];
  ops[0] = ops[1] = 0;

  // static int loop_id = 0;
  // loop_id++;
  // clock_t t0 = clock();
  #pragma omp parallel for num_threads(nb_threads)
  for (int t = 0; t < nb_threads; ++t)
  {
    // clock_t t0 = clock();
    int i;
    for (i = 0; i < c->mo; ++i) {
      int oc = ocs[t][i];
      ops[oc] = 0;

      if (oc < 2 || oc > c->mo)
        break;
      for (int j=1; j <= (oc-1)/2; ++j) {
        int oa = oc-j, ob = j;            // oa > ob >= 1
        const idx_t *l = dc->L[oa*hod + ob];
        assert(l);

        if (bget(nza,oa) && bget(nzb,ob) && bget(nza,ob) && bget(nzb,oa)) {
          ops[oc] += hpoly_sym_mul(ca,cb,cc, l, oa,ob,ps);
          c_nzs[t] = bset(c_nzs[t],oc);
        }
        else if (bget(nza,oa) && bget(nzb,ob)) {
          ops[oc] += hpoly_asym_mul(ca,cb,cc, l, oa,ob,ps);
          c_nzs[t] = bset(c_nzs[t],oc);
        }
        else if (bget(nza,ob) && bget(nzb,oa)) {
          ops[oc] += hpoly_asym_mul(cb,ca,cc, l, oa,ob,ps);
          c_nzs[t] = bset(c_nzs[t],oc);
        }
      }

      if (! (oc & 1)) {  // even oc, triang matrix
        int hoc = oc/2;
        const idx_t *l = dc->L[hoc*hod + hoc];
        assert(l);
        if (bget(nza,hoc) && bget(nzb,hoc) ) {
          ops[oc] += hpoly_triang_mul(ca,cb,cc, l, hoc,ps);
          c_nzs[t] = bset(c_nzs[t],oc);
        }
      }
    }
    // clock_t t1 = clock();
    // printf("time_omp[%d,%d]: %g\n", loop_id, t, ((double)t1-t0)/CLOCKS_PER_SEC);
  }
  // clock_t t1 = clock();
  // printf("time_omp[%d]: %g\n", loop_id, ((double)t1-t0)/CLOCKS_PER_SEC);

  for (int t = 0; t < nb_threads; ++t)
    c->nz |= c_nzs[t];

  // if (printed)
  //   return;

  // printed = 1;
  // fprintf(stderr, "\n ops: ");
  // for (int o = 2; o <= c->mo; ++o)
  //   fprintf(stderr, "[%d]=%d ", o, ops[o]);

  // fprintf(stderr, "\n cumulated ops: ");
  // int accum = 0;
  // for (int o = 2; o <= c->mo; ++o) {
  //   accum += ops[o];
  //   fprintf(stderr, "[%d]=%d ", o, accum);
  // }

  // fprintf(stderr, "\n mul_threads: %d\n", nb_threads);
  // for (int t = 0; t < nb_threads; ++t) {
  //   int ops_per_thread = 0;
  //   fprintf(stderr, "%d :\t", t);
  //   for (int i = 0; i < c->mo && ocs[t][i] > 0; ++i) {
  //     int ord = ocs[t][i];
  //     ops_per_thread += ops[ord];
  //     fprintf(stderr, "%d ", ord);
  //   }
  //   fprintf(stderr, "ops=%d\n", ops_per_thread);
  // }
}
#endif

static inline void
scale_and_accum(num_t v, const T *a, T *c)
{
#ifdef TRACE
  printf("scale_and_accum %lf\n", v);
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  D *d = c->desc;
  const num_t *ca = a->coef;
        num_t *cc = c->coef;
  ord_t new_mo = min_ord(a->mo,c->to,d->trunc);
  for (int i = d->hpoly_To_idx[c->mo+1]; i < d->hpoly_To_idx[new_mo+1]; ++i)
    cc[i] = 0;
  for (int i = 0; i < d->hpoly_To_idx[new_mo+1]; ++i)
    cc[i] += v * ca[i];
  c->mo = new_mo > c->mo ? new_mo : c->mo;
  c->nz = btrunc(badd(c->nz,a->nz),c->mo);
}


// --- PUBLIC FUNCTIONS -------------------------------------------------------

#include <math.h>

#ifdef UNUSED
/* tpsa_i and tpsa_interface don't have dacom */
num_t
mad_tpsa_comp(const T *a, const T *b)
{
  assert(a && b);
  ensure(a->desc == b->desc);
  num_t norm = 0;
  ord_t amo = min_ord(a->mo, a->to, a->desc->trunc),
        bmo = min_ord(b->mo, b->to, b->desc->trunc);
  int len_a = a->desc->hpoly_To_idx[amo+1],
      len_b = b->desc->hpoly_To_idx[bmo+1],
      i     = 0;
  for ( ; i < imin(len_a,len_b); ++i) norm += fabs(a->coef[i] - b->coef[i]);
  for ( ; i <      len_a       ; ++i) norm += fabs(a->coef[i]);
  for ( ; i <      len_b       ; ++i) norm += fabs(b->coef[i]);
  return norm;
}

void
mad_tpsa_pos(const T *a, T *c)
{
  assert(a);
  ensure(a->desc == c->desc);
  c->mo = min_ord(a->mo, a->desc->trunc);
  for (int i = 0; i < c->desc->hpoly_To_idx[c->mo+1]; ++i)
    c->coef[i] = fabs(a->coef[i]);
  c->nz = btrunc(a->nz,c->mo);
}
#endif // unused

void
mad_tpsa_der(const T *a, int var, T *c)
{
#ifdef TRACE
  printf("mad_tpsa_der\n");
#endif
  assert(a && c);
  ensure(var > 0 && var <= a->desc->nv);

  D *d = a->desc;

  ensure(0 && "OUTDATED: mo >= 1");
  // prepare destination; minimal cleanup
  ord_t c_mo = min_ord(a->mo-1, c->to, d->trunc);
  c->mo = c->nz = 0;
  for (int i = 0; i < d->hpoly_To_idx[c_mo+1]; ++i)
    c->coef[i] = 0;

  // ord 0
  num_t val = 0;
  if ((val = mad_tpsa_geti(a,var))) {
    c->coef[0] = val;
    c->nz = bset(0,0);  // set ord 0
  }

  if (a->mo == 1)
    return;

  #define DER_USING_L_MATRIX
  #ifdef DER_USING_L_MATRIX
  // get source indexes from L[oc][1], oc = [1..c_mo]
  const num_t *ca = a->coef;

  // ord 1  -- triangular lc
  ord_t oc = 1, ho = d->mo/2;
  idx_t ia, *lc = d->L[oc*ho + 1], *pi = d->hpoly_To_idx;
  if (bget(a->nz,2)) {
    for (int ic = pi[oc]; ic < var; ++ic) {
      ia = lc[ hpoly_idx_triang(ic-pi[oc], var-pi[1]) ];
      if (ia >= 0) {
        assert(pi[oc+1] <= ia && ia < pi[oc+2]);
        mad_tpsa_seti(c,ic,ca[ia]);
      }
    }
    ia = lc[ hpoly_idx_triang(var-pi[1],var-pi[1]) ];
    mad_tpsa_seti(c,var,2*ca[ia]);

    for (int ic = var+1; ic < pi[oc+1]; ++ic) {
      ia = lc[ hpoly_idx_triang(var-pi[1], ic-pi[oc]) ];
      if (ia >= 0) {
        assert(pi[oc+1] <= ia && ia < pi[oc+2]);
        mad_tpsa_seti(c,ic,ca[ia]);
      }
    }
  }

  // ords [2..c_mo]  -- rectangular lc
  int ord_size = -1;
  for (oc = 2; oc <= c_mo; ++oc)
    if (bget(a->nz,oc+1)) {
      lc = d->L[oc*ho + 1];
      ord_size = pi[oc+1] - pi[oc];
      for (int ic = pi[oc]; ic < pi[oc+1]; ++ic) {
        ia = lc[ hpoly_idx_rect(var-pi[1], ic-pi[oc], ord_size) ];
        if (ia >= 0) {
          assert(pi[oc+1] <= ia && ia < pi[oc+2]);
          mad_tpsa_seti(c,ic, d->To[ia][var-1] * ca[ia]);
        }
      }
    }
  #else  // not DER_USING_L_MATRIX

  // #ifdef UNUSED
  // TODO: switch between the two methods depending on NV ?
  idx_t idx_der = -1, *pi = d->hpoly_To_idx;
  var--;    // monos are 0-indexed
  ord_t der_mono[d->nv];
  for (int o = 1; o <= c_mo+1; ++o)
    if (bget(a->nz,o))
      for (int m = pi[o]; m < pi[o+1]; ++m)
        if (a->coef[m] && d->To[m][var]) {
          mono_cpy(d->nv,d->To[m],der_mono);
          der_mono[var]--;
          idx_der = desc_get_idx(d, d->nv, der_mono);
          mad_tpsa_seti(c,idx_der, a->coef[m] * d->To[m][var]);
        }
  #endif // DER_USING_L_MATRIX
  #undef DER_USING_L_MATRIX
}

void
mad_tpsa_axpby(num_t c1, const T *a, num_t c2, const T *b, T *c)
{
  // this can be done in place [i.e. (a or b) == c ]
#ifdef TRACE
  printf("tpsa_axpby\n");
#endif
  assert(a && b && c);
  ensure(a->desc == b->desc && b->desc == c->desc);
  ensure(a != c && b != c);

  if (!c1 && !c2) {
    mad_tpsa_clean(c);
    return;
  }

  if (a->mo > b->mo)  {
    swap(&a,&b);
    num_t tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  c->mo = min_ord(b->mo, c->to, c->desc->trunc);
  c->nz = btrunc(badd(a->nz,b->nz), c->mo);
  int ac = c->desc->hpoly_To_idx[min_ord2(a->mo,c->mo)+1];
  int bc = c->desc->hpoly_To_idx[c->mo+1];

  const num_t *ca = a->coef, *cb = b->coef;
        num_t *cc = c->coef;
  int i = 0;
  for(; i < ac; ++i) cc[i] = c1*ca[i] + c2*cb[i];
  for(; i < bc; ++i) cc[i] =            c2*cb[i];
}

void
mad_tpsa_add(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("tpsa_add\n");
#endif
  assert(a && b && c);
  ensure(a->desc == b->desc && a->desc == c->desc);
  ensure(a != c && b != c);

  if (a->mo > b->mo) swap(&a,&b);
  c->mo = min_ord(b->mo, c->to, c->desc->trunc);
  c->nz = btrunc(badd(a->nz,b->nz), c->mo);
  int ac = c->desc->hpoly_To_idx[min_ord2(a->mo,c->mo)+1];
  int bc = c->desc->hpoly_To_idx[c->mo+1];

  const num_t *ca = a->coef, *cb = b->coef;
        num_t *cc = c->coef;
  int i = 0;
  for(; i < ac; ++i) cc[i] = ca[i] + cb[i];
  for(; i < bc; ++i) cc[i] =         cb[i];
 }

void
mad_tpsa_sub(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("tpsa_sub\n");
#endif
  assert(a && b && c);
  ensure(a->desc == b->desc && a->desc == c->desc);
  ensure(a != c && b != c);

  if (a->mo > b->mo) swap(&a,&b);
  c->mo = min_ord(b->mo, c->to, c->desc->trunc);
  c->nz = btrunc(badd(a->nz,b->nz), c->mo);
  int ac = c->desc->hpoly_To_idx[min_ord2(a->mo,c->mo)+1];
  int bc = c->desc->hpoly_To_idx[c->mo+1];

  const num_t *ca = a->coef, *cb = b->coef;
        num_t *cc = c->coef;
  int i = 0;
  for(; i < ac; ++i) cc[i] = ca[i] - cb[i];
  for(; i < bc; ++i) cc[i] =       - cb[i];
}

void
mad_tpsa_mul(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("tpsa_mul\n");
#endif
  assert(a && b && c);
  // tpsa itself can't be just ord 0; use scale for that, at map level
  assert(a->mo >= 1 && b->mo >= 1);
  // ensure(a->desc == b->desc && a->desc == c->desc);
  ensure(a != c && b != c);

  D *d = a->desc;
  num_t a0 = a->coef[0], b0 = b->coef[0];
  c->coef[0] = a0 * b0;

  for (int i = 1; i <= d->nv; ++i)
    c->coef[i] = a0 * b->coef[i] + b0 * a->coef[i];

  if (d->trunc == 1) {  // skip checks, assume everything is set
    c->mo = 1;
    c->nz = 3;
    return;
  }

  c->mo = min_ord(a->mo + b->mo, c->to, d->trunc);
  assert(c->mo >= 1);

  c->nz = 0;
  if (a0) c->nz = btrunc(badd(c->nz,b->nz),c->mo);
  if (b0) c->nz = btrunc(badd(c->nz,a->nz),c->mo);

  if (c->mo >= 2) {
    if (a->mo > b->mo) swap(&a,&b);
    a0 = a->coef[0], b0 = b->coef[0];

    const num_t *ca = a->coef, *cb = b->coef;
          num_t *cc = c->coef;
    int lim_a = d->hpoly_To_idx[min_ord2(a->mo,c->mo)+1];
    int lim_b = d->hpoly_To_idx[min_ord2(b->mo,c->mo)+1];
    int lim_c = d->hpoly_To_idx[               c->mo +1];
    int i     = d->hpoly_To_idx[2];
    for (; i < lim_a; ++i) cc[i] = b0*ca[i] + a0*cb[i];
    for (; i < lim_b; ++i) cc[i] =            a0*cb[i];
    for (; i < lim_c; ++i) cc[i] = 0;

    hpoly_mul(a, b, c);
  }
}

void
mad_tpsa_div(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("tpsa_div\n");
#endif
  assert(a && b && c);
  ensure(a->desc == b->desc && a->desc == c->desc);
  ensure(b->coef[0] != 0);

  D *d = a->desc;
  // TODO: outdated, mo always >= 1
  if (d->trunc == 0 || c->to == 0) {
    c->mo = 0;
    c->nz = bset(0,0);  // has ord 0
    c->coef[0] = a->coef[0] / b->coef[0];
    return;
  }

  T *tmp = mad_tpsa_newd(d,&d->trunc);
  mad_tpsa_inv(b,tmp);
  mad_tpsa_mul(a,tmp,c);
  mad_tpsa_del(tmp);
}

void
mad_tpsa_cdiv(const T *a, num_t v, T *c)
{
#ifdef TRACE
  printf("tpsa_constant_div\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  mad_tpsa_scale(1/v,a,c);
}

void
mad_tpsa_divc(num_t v, const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_div_constant\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  T *tmp = mad_tpsa_new(a);
  mad_tpsa_cdiv(a,v,tmp);
  mad_tpsa_inv(tmp,c);
  mad_tpsa_del(tmp);
}

void
mad_tpsa_scale(num_t v, const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_scale %lf\n", v);
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  if (v == 0) {
    mad_tpsa_clean(c);
    return;
  }

  D *d = a->desc;
  c->mo = min_ord(a->mo, c->to, d->trunc);
  c->nz = btrunc(a->nz,c->mo);
  for (int i = 0; i < d->hpoly_To_idx[c->mo+1]; ++i)
    c->coef[i] = v * a->coef[i];
}

void
mad_tpsa_poisson(const T *a, const T *b, T *c, int n)
{
  // C = [A,B] (POISSON BRACKET, 2*n: No of PHASEVARS
  assert(a && b && c);
  ensure(a->desc == b->desc && b->desc == c->desc);

  T *is[4];
  for (int i = 0; i < 4; ++i)
    is[i] = mad_tpsa_newd(a->desc,&a->desc->trunc);

  for (int i = 1; i <= n; ++i) {
    mad_tpsa_der(a, 2*i - 1, is[0]);
    mad_tpsa_der(b, 2*i    , is[1]);
    mad_tpsa_mul(is[0],is[1],is[2]);
    mad_tpsa_add(is[3],is[2],is[0]);
    mad_tpsa_copy(is[0],is[3]);

    mad_tpsa_der(a, 2*i    , is[0]);
    mad_tpsa_der(b, 2*i - 1, is[1]);
    mad_tpsa_mul(is[0],is[1],is[2]);
    mad_tpsa_sub(is[3],is[2],is[0]);
    mad_tpsa_copy(is[0],is[3]);
  }

  mad_tpsa_copy(is[3], c);
  for (int i = 0; i < 4; ++i)
    mad_tpsa_del(is[i]);
}

#ifdef UNUSED
void
mad_tpsa_pow(const T *a, T *orig_res, int p)
{
#ifdef TRACE
  printf("tpsa_pow %p to %d\n", (void*)a, p);
#endif
  assert(a && orig_res);
  ensure(a->desc == orig_res->desc);
  ensure(p >= 0);

  if (p == 0) {
    mad_tpsa_clean(orig_res);
    mad_tpsa_seti(orig_res, 0, 1);
    return;
  }
  if (p == 1) {
    mad_tpsa_copy(a, orig_res);
    return;
  }

  // init: base = a, r = 1, tmp
  T *base = mad_tpsa_new(a), *r = orig_res, *tmp_res = mad_tpsa_new(a);
  mad_tpsa_copy(a, base);
  mad_tpsa_clean(r);
  mad_tpsa_seti(r, 0, 1);

  while(p > 1) {
    if (p & 1) {
      mad_tpsa_mul(base, r, tmp_res);
      swap(&r, &tmp_res);
    }
    mad_tpsa_mul(base, base, tmp_res);
    swap(&base, &tmp_res);
    p /= 2;
  }
  mad_tpsa_mul(base, r, tmp_res);

  // save result and dealloc
  mad_tpsa_copy(tmp_res, orig_res);
  if (base    != orig_res) mad_tpsa_del(base);
  if (r       != orig_res) mad_tpsa_del(r);
  if (tmp_res != orig_res) mad_tpsa_del(tmp_res);
}
#endif // UNUSED

#undef TRACE
#undef T
#undef D
#endif
