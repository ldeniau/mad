#ifndef TPSA_OPS_TEMPLATE
#define TPSA_OPS_TEMPLATE

#define T struct tpsa
#define D struct tpsa_desc

// #define TRACE

// --- LOCAL FUNCTIONS --------------------------------------------------------

static inline void
hpoly_triang_mul(const num_t *ca, const num_t *cb, num_t *cc, int nb,
                 const idx_t l[], const int *idx[])
{
  // asymm: c[2 2] = a[2 0]*b[0 2] + a[0 2]*b[2 0]
  for (idx_t ib = 0; ib < nb; ib++)
  for (idx_t ia = idx[0][ib]; ia < idx[1][ib]; ia++) {
    int ic = l[hpoly_idx_rect(ib,ia,nb)];
    if (ic >= 0)
      cc[ic] = cc[ic] + ca[ia]*cb[ib] + (ia == ib ? 0 : ca[ib]*cb[ia]);
  }
}

static inline void
hpoly_sym_mul(const num_t *ca1, const num_t *cb1, const num_t *ca2, const num_t *cb2,
              num_t *cc, int na, int nb, const idx_t l[], const int *idx[])
{
  // na > nb so longer loop is inside
  for (idx_t ib=0; ib < nb; ib++)
  for (idx_t ia=idx[0][ib]; ia < idx[1][ib]; ia++) {
    int ic = l[hpoly_idx_rect(ib, ia, na)];
    if (ic >= 0)
      cc[ic] = cc[ic] + ca1[ia]*cb1[ib] + ca2[ib]*cb2[ia];
  }
}

static inline void
hpoly_asym_mul(const num_t *ca, const num_t *cb, num_t *cc, int na, int nb,
               const idx_t l[], const int *idx[])
{
  // oa > ob so longer loop is inside
  for (idx_t ib=0; ib < nb; ib++)
  for (idx_t ia=idx[0][ib]; ia < idx[1][ib]; ia++) {
    int ic = l[hpoly_idx_rect(ib,ia,na)];
    if (ic >= 0)
      cc[ic] = cc[ic] + ca[ia]*cb[ib];
  }
}

static inline void
hpoly_mul(const T *a, const T *b, T *c, const ord_t *ocs, bit_t *cnz, int in_parallel)
{
#ifdef TRACE
  printf("hpoly_mul\n");
#endif
  D *d = c->desc;
  int *pi = d->hpoly_To_idx, hod = d->mo/2;
  const num_t *ca = a->coef,  *cb = b->coef;
        num_t *cc = c->coef;
        bit_t nza = a->nz  ,  nzb = b->nz;

  for (int i = 0; ocs[i]; ++i) {
    if (ocs[i] > c->hi + 1 || (ocs[i] == c->hi + 1 && !in_parallel))
      continue;

    ord_t oc = ocs[i];
    int idx0 = 0, idx1 = 2;
    if (in_parallel && ocs[i] >= c->hi) {
      oc = c->hi;
      if (ocs[i] == c->hi) idx1 = 1;
      else                 idx0 = 1;
    }

    for (int j=1; j <= (oc-1)/2; ++j) {
      int oa = oc-j, ob = j;            // oa > ob >= 1
      int na = pi[oa+1] - pi[oa];
      int nb = pi[ob+1] - pi[ob];
      const idx_t *lc  = d->L[oa*hod + ob];
      assert(lc);
      const int *idx[2] = { d->L_idx[oa*hod + ob][idx0],
                            d->L_idx[oa*hod + ob][idx1]};
      assert(idx[0] && idx[1]);

      if (bget(nza,oa) && bget(nzb,ob) && bget(nza,ob) && bget(nzb,oa)) {
        hpoly_sym_mul(ca+pi[oa],cb+pi[ob], ca+pi[ob],cb+pi[oa], cc, na,nb, lc, idx);
        *cnz = bset(*cnz,oc);
      }
      else if (bget(nza,oa) && bget(nzb,ob)) {
        hpoly_asym_mul(ca+pi[oa],cb+pi[ob],cc, na,nb, lc, idx);
        *cnz = bset(*cnz,oc);
      }
      else if (bget(nza,ob) && bget(nzb,oa)) {
        hpoly_asym_mul(cb+pi[oa],ca+pi[ob],cc, na,nb, lc, idx);
        *cnz = bset(*cnz,oc);
      }
    }

    if (! (oc & 1)) {  // even oc, triang matrix
      int hoc = oc/2, nb = pi[hoc+1]-pi[hoc];
      const idx_t *lc = d->L[hoc*hod + hoc];
      const int *idx[2] = { d->L_idx[hoc*hod + hoc][idx0],
                            d->L_idx[hoc*hod + hoc][idx1] };
      assert(lc);
      if (bget(nza,hoc) && bget(nzb,hoc) ) {
        hpoly_triang_mul(ca+pi[hoc],cb+pi[hoc],cc, nb, lc, idx);
        *cnz = bset(*cnz,oc);
      }
    }
  }
}

#ifdef _OPENMP
static inline void
hpoly_mul_par(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("poly_mul_parallel\n");
#endif

  int nb_threads = get_num_threads();
  bit_t c_nzs[nb_threads];
  for (int t = 0; t < nb_threads; ++t)
    c_nzs[t] = c->nz;

  #pragma omp parallel for
  for (int t = 0; t < nb_threads; ++t)
    hpoly_mul(a,b,c,c->desc->ocs[t],&c_nzs[t],1);

  for (int t = 0; t < nb_threads; ++t)
    c->nz |= c_nzs[t];
}
#endif

static inline void
hpoly_mul_ser(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("poly_mul_serial\n");
#endif
  hpoly_mul(a,b,c,c->desc->ocs[0],&c->nz,0);
}

static inline int
der_coef(idx_t ia, idx_t di, ord_t der_ord, const D* d)
{
  if (der_ord == 1) // der against var
    return d->To[ia][di-1];

  const ord_t *msrc = d->To[ia], *mder = d->To[di];
  if (!mono_leq(d->nv,mder,msrc))
    return 0;

  int c = 1;
  for (int v = 0; v < d->nv; ++v)
    for (int o = 0; o < mder[v]; ++o)
        c *= msrc[v] - o;
  // printf("ia=%d di=%d c=%d\n", ia, di, c);
  return c;
}

static inline void
hpoly_der_lt(const num_t ca[], num_t cc[], idx_t idx, ord_t oc, ord_t ord, bit_t *cnz, const D *d)
{
  const ord_t ho = d->mo/2;
  const idx_t *lc = d->L[ord*ho + oc], *pi = d->hpoly_To_idx;
  int nc = pi[oc+1] - pi[oc], cols = pi[ord+1] - pi[ord];
  // idx = idx - pi[ord];
  for (int ic = 0; ic < nc; ++ic) {
    idx_t ia = lc[hpoly_idx_rect(ic,idx-pi[ord],cols)];
    if (ia >= 0 && ca[ia]) {
      assert(pi[oc+ord] <= ia && ia < pi[oc+ord+1]);
      cc[ic] = ca[ia] * der_coef(ia,idx,ord,d);
      *cnz = bset(*cnz,oc);
    }
  }
}

static inline void
hpoly_der_eq(const num_t ca[], num_t cc[], idx_t idx, ord_t oc, ord_t ord, bit_t *cnz, const D *d)
{
  const ord_t ho = d->mo/2;
  const idx_t *lc = d->L[ord*ho + oc], *pi = d->hpoly_To_idx;
  int nc = pi[ord+1] - pi[ord];
  idx_t idx_shifted = idx - pi[ord];
  for (int ic = 0; ic < nc; ++ic) {
    idx_t ia = lc[hpoly_idx_rect(imax(ic,idx_shifted),imin(ic,idx_shifted),nc)];
    if (ia >= 0 && ca[ia]) {
      assert(pi[oc+ord] <= ia && ia < pi[oc+ord+1]);
      cc[ic] = ca[ia] * der_coef(ia,idx,ord,d);
      *cnz = bset(*cnz,oc);
    }
  }
}

static inline void
hpoly_der_gt(const num_t ca[], num_t cc[], idx_t idx, ord_t oc, ord_t ord, bit_t *cnz, const D *d)
{
  const ord_t ho = d->mo/2;
  const idx_t *lc = d->L[oc*ho + ord], *pi = d->hpoly_To_idx;
  int nc = pi[oc+1] - pi[oc];
  idx_t idx_shifted = idx - pi[ord];
  for (int ic = 0; ic < nc; ++ic) {
    idx_t ia = lc[hpoly_idx_rect(idx_shifted,ic,nc)];
    if (ia >= 0 && ca[ia]) {
      assert(pi[oc+ord] <= ia && ia < pi[oc+ord+1]);
      cc[ic] = ca[ia] * der_coef(ia,idx,ord,d);
      *cnz = bset(*cnz,oc);
    }
  }
}

static inline void
hpoly_der(const T *a, idx_t idx, ord_t ord, T *c)
{
  D *d = c->desc;
  idx_t *pi = d->hpoly_To_idx;
  const num_t *ca = a->coef;
        num_t *cc;

  c->hi = min_ord(c->mo, d->trunc, a->hi-ord);
  for (int oc = 1; oc <= c->hi; ++oc)
    if (bget(a->nz,oc+ord)) {
      cc = c->coef + pi[oc];
      if (oc < ord)
        hpoly_der_lt(ca,cc,idx,oc,ord,&c->nz,d);
      else if (oc == ord)
        hpoly_der_eq(ca,cc,idx,oc,ord,&c->nz,d);
      else
        hpoly_der_gt(ca,cc,idx,oc,ord,&c->nz,d);
    }
}

static inline void
scale_and_accum(num_t v, const T *a, T *c)
{
#ifdef TRACE
  printf("scale_and_accum %lf\n", v);
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  D *d = c->desc;
  const num_t *ca = a->coef;
        num_t *cc = c->coef;
  ord_t new_hi = min_ord(a->hi,c->mo,d->trunc);
  for (int i = d->hpoly_To_idx[c->hi+1]; i < d->hpoly_To_idx[new_hi+1]; ++i)
    cc[i] = 0;
  for (int i = 0; i < d->hpoly_To_idx[new_hi+1]; ++i)
    cc[i] += v * ca[i];
  c->hi = new_hi > c->hi ? new_hi : c->hi;
  c->nz = btrunc(badd(c->nz,a->nz),c->hi);
}

// --- PUBLIC FUNCTIONS -------------------------------------------------------

#include <math.h>

#ifdef UNUSED
/* tpsa_i and tpsa_interface don't have dacom */
num_t
mad_tpsa_comp(const T *a, const T *b)
{
  assert(a && b);
  ensure(a->desc == b->desc);
  num_t norm = 0;
  ord_t ahi = min_ord2(a->hi, a->desc->trunc),
        bhi = min_ord2(b->hi, b->desc->trunc);
  int len_a = a->desc->hpoly_To_idx[ahi+1],
      len_b = b->desc->hpoly_To_idx[bhi+1],
      i     = 0;
  for ( ; i < imin(len_a,len_b); ++i) norm += fabs(a->coef[i] - b->coef[i]);
  for ( ; i <      len_a       ; ++i) norm += fabs(a->coef[i]);
  for ( ; i <      len_b       ; ++i) norm += fabs(b->coef[i]);
  return norm;
}

void
mad_tpsa_pos(const T *a, T *c)
{
  assert(a);
  ensure(a->desc == c->desc);
  c->hi = min_ord(a->hi, a->desc->trunc);
  for (int i = 0; i < c->desc->hpoly_To_idx[c->hi+1]; ++i)
    c->coef[i] = fabs(a->coef[i]);
  c->nz = btrunc(a->nz,c->hi);
}
#endif // unused

void
mad_tpsa_der(const T *a, int var, T *c)
{
#ifdef TRACE
  printf("mad_tpsa_der\n");
#endif
  assert(a && c && a != c);
  ensure(var > 0 && var <= a->desc->nv);

  D *d = a->desc;

  // ord 0 & cleanup
  mad_tpsa_setConst(c, a->coef[var]);
  if (a->hi <= 1)
    return;

  c->hi = min_ord(c->mo, d->trunc, a->hi-1);

  idx_t *pi = d->hpoly_To_idx;
  const num_t *ca = a->coef;

  ord_t der_ord = 1, oc = 1;
  if (bget(a->nz,2))
      hpoly_der_eq(ca,c->coef+pi[oc],var,oc,der_ord,&c->nz,d);
  for (oc = 2; oc <= c->hi; ++oc)
    if (bget(a->nz,oc+1))
      hpoly_der_gt(ca,c->coef+pi[oc],var,oc,der_ord,&c->nz,d);
}

void
mad_tpsa_der_m(const T *a, int n, const ord_t mono[n], T *c)
{
#ifdef TRACE
  printf("mad_tpsa_der_m\n");
#endif
  assert(a && c && a != c);
  assert(a->desc == c->desc);
  ensure(desc_mono_isvalid(a->desc,n,mono));

  ord_t der_ord = mono_sum(n,mono);
  ensure(der_ord > 0);
  idx_t idx = desc_get_idx(a->desc,n,mono);
  if (idx < a->desc->hpoly_To_idx[2]) {  // fallback on simple version
    mad_tpsa_der(a,idx,c);
    return;
  }

  // ord 0 & setup
  mad_tpsa_setConst(c,mad_tpsa_geti(a,idx) * der_coef(idx,idx,der_ord,a->desc));
  if (a->hi <= der_ord)
    return;

  // ords 1..a->hi - 1
  hpoly_der(a,idx,der_ord,c);
}

void
mad_tpsa_axpby(num_t c1, const T *a, num_t c2, const T *b, T *c)
{
#ifdef TRACE
  printf("tpsa_axpby\n");
#endif
  assert(a && b && c);
  ensure(a->desc == b->desc && b->desc == c->desc);
  ensure(a != c && b != c);

  if (!c1 && !c2) {
    mad_tpsa_clean(c);
    return;
  }

  if (a->hi > b->hi)  {
    swap(&a,&b);
    num_t tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  c->hi = min_ord(b->hi, c->mo, c->desc->trunc);
  c->nz = btrunc(badd(a->nz,b->nz), c->hi);
  int ac = c->desc->hpoly_To_idx[min_ord2(a->hi,c->hi)+1];
  int bc = c->desc->hpoly_To_idx[c->hi+1];

  const num_t *ca = a->coef, *cb = b->coef;
        num_t *cc = c->coef;
  int i = 0;
  for(; i < ac; ++i) cc[i] = c1*ca[i] + c2*cb[i];
  for(; i < bc; ++i) cc[i] =            c2*cb[i];
}

void
mad_tpsa_add(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("tpsa_add\n");
#endif
  assert(a && b && c);
  ensure(a->desc == b->desc && a->desc == c->desc);
  ensure(a != c && b != c);

  if (a->hi > b->hi) swap(&a,&b);
  c->hi = min_ord(b->hi, c->mo, c->desc->trunc);
  c->nz = btrunc(badd(a->nz,b->nz), c->hi);
  int ac = c->desc->hpoly_To_idx[min_ord2(a->hi,c->hi)+1];
  int bc = c->desc->hpoly_To_idx[c->hi+1];

  const num_t *ca = a->coef, *cb = b->coef;
        num_t *cc = c->coef;
  int i = 0;
  for(; i < ac; ++i) cc[i] = ca[i] + cb[i];
  for(; i < bc; ++i) cc[i] =         cb[i];
 }

void
mad_tpsa_sub(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("tpsa_sub\n");
#endif
  assert(a && b && c);
  ensure(a->desc == b->desc && a->desc == c->desc);
  ensure(a != c && b != c);

  if (a->hi > b->hi) swap(&a,&b);
  c->hi = min_ord(b->hi, c->mo, c->desc->trunc);
  c->nz = btrunc(badd(a->nz,b->nz), c->hi);
  int ac = c->desc->hpoly_To_idx[min_ord2(a->hi,c->hi)+1];
  int bc = c->desc->hpoly_To_idx[c->hi+1];

  const num_t *ca = a->coef, *cb = b->coef;
        num_t *cc = c->coef;
  int i = 0;
  for(; i < ac; ++i) cc[i] = ca[i] - cb[i];
  for(; i < bc; ++i) cc[i] =       - cb[i];
}

void
mad_tpsa_mul(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("tpsa_mul\n");
#endif
  assert(a && b && c);
  ensure(a->desc == b->desc && a->desc == c->desc);
  ensure(a != c && b != c);

  D *d = a->desc;
  num_t a0 = a->coef[0], b0 = b->coef[0];
  c->coef[0] = a0 * b0;

  // cannot optimize ord 0, i.e. quit computation if c->hi == 0
  // because the extra checks have overhead on ord 1
  assert(a->hi >= 1 && b->hi >= 1);

  for (int i = 1; i <= d->nv; ++i)
    c->coef[i] = a0 * b->coef[i] + b0 * a->coef[i];

  if (d->trunc == 1) {  // skip checks, assume everything is set
    c->hi = 1;
    c->nz = 3;
    return;
  }

  c->hi = min_ord(a->hi + b->hi, c->mo, d->trunc);
  assert(c->hi >= 1);

  c->nz = 0;
  if (a0) c->nz = btrunc(badd(c->nz,b->nz),c->hi);
  if (b0) c->nz = btrunc(badd(c->nz,a->nz),c->hi);

  if (c->hi >= 2) {
    if (a->hi > b->hi) swap(&a,&b);
    a0 = a->coef[0], b0 = b->coef[0];

    const num_t *ca = a->coef, *cb = b->coef;
          num_t *cc = c->coef;
    int lim_a = d->hpoly_To_idx[min_ord2(a->hi,c->hi)+1];
    int lim_b = d->hpoly_To_idx[min_ord2(b->hi,c->hi)+1];
    int lim_c = d->hpoly_To_idx[               c->hi +1];
    int i     = d->hpoly_To_idx[2];
    for (; i < lim_a; ++i) cc[i] = b0*ca[i] + a0*cb[i];
    for (; i < lim_b; ++i) cc[i] =            a0*cb[i];
    for (; i < lim_c; ++i) cc[i] = 0;

    #ifdef _OPENMP
    if (c->hi >= 12)
      hpoly_mul_par(a,b,c);
    else
    #endif
      hpoly_mul_ser(a,b,c);
  }
}

void
mad_tpsa_div(const T *a, const T *b, T *c)
{
#ifdef TRACE
  printf("tpsa_div\n");
#endif
  assert(a && b && c);
  ensure(a->desc == b->desc && a->desc == c->desc);
  ensure(b->coef[0] != 0);

  D *d = a->desc;
  T *tmp = mad_tpsa_newd(d,&d->trunc);
  mad_tpsa_inv(b,tmp);
  mad_tpsa_mul(a,tmp,c);
  mad_tpsa_del(tmp);
}

void
mad_tpsa_cdiv(const T *a, num_t v, T *c)
{
#ifdef TRACE
  printf("tpsa_constant_div\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  mad_tpsa_scale(1/v,a,c);
}

void
mad_tpsa_divc(num_t v, const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_div_constant\n");
#endif
  assert(a && c);
  ensure(a->desc == c->desc);

  T *tmp = mad_tpsa_new(a);
  mad_tpsa_cdiv(a,v,tmp);
  mad_tpsa_inv(tmp,c);
  mad_tpsa_del(tmp);
}

void
mad_tpsa_scale(num_t v, const T *a, T *c)
{
#ifdef TRACE
  printf("tpsa_scale %lf\n", v);
#endif
  assert(a && c);
  ensure(a->desc == c->desc);
  if (v == 0) {
    mad_tpsa_clean(c);
    return;
  }

  D *d = a->desc;
  c->hi = min_ord(a->hi, c->mo, d->trunc);
  c->nz = btrunc(a->nz,c->hi);
  for (int i = 0; i < d->hpoly_To_idx[c->hi+1]; ++i)
    c->coef[i] = v * a->coef[i];
}

void
mad_tpsa_poisson(const T *a, const T *b, T *c, int n)
{
  // C = [A,B] (POISSON BRACKET, 2*n: No of PHASEVARS
  assert(a && b && c);
  ensure(a->desc == b->desc && b->desc == c->desc);

  T *is[4];
  for (int i = 0; i < 4; ++i)
    is[i] = mad_tpsa_newd(a->desc,&a->desc->trunc);

  for (int i = 1; i <= n; ++i) {
    mad_tpsa_der(a, 2*i - 1, is[0]);
    mad_tpsa_der(b, 2*i    , is[1]);
    mad_tpsa_mul(is[0],is[1],is[2]);
    mad_tpsa_add(is[3],is[2],is[0]);
    mad_tpsa_copy(is[0],is[3]);

    mad_tpsa_der(a, 2*i    , is[0]);
    mad_tpsa_der(b, 2*i - 1, is[1]);
    mad_tpsa_mul(is[0],is[1],is[2]);
    mad_tpsa_sub(is[3],is[2],is[0]);
    mad_tpsa_copy(is[0],is[3]);
  }

  mad_tpsa_copy(is[3], c);
  for (int i = 0; i < 4; ++i)
    mad_tpsa_del(is[i]);
}

#ifdef UNUSED
void
mad_tpsa_pow(const T *a, T *orig_res, int p)
{
#ifdef TRACE
  printf("tpsa_pow %p to %d\n", (void*)a, p);
#endif
  assert(a && orig_res);
  ensure(a->desc == orig_res->desc);
  ensure(p >= 0);

  if (p == 0) {
    mad_tpsa_clean(orig_res);
    mad_tpsa_seti(orig_res, 0, 1);
    return;
  }
  if (p == 1) {
    mad_tpsa_copy(a, orig_res);
    return;
  }

  // init: base = a, r = 1, tmp
  T *base = mad_tpsa_new(a), *r = orig_res, *tmp_res = mad_tpsa_new(a);
  mad_tpsa_copy(a, base);
  mad_tpsa_clean(r);
  mad_tpsa_seti(r, 0, 1);

  while(p > 1) {
    if (p & 1) {
      mad_tpsa_mul(base, r, tmp_res);
      swap(&r, &tmp_res);
    }
    mad_tpsa_mul(base, base, tmp_res);
    swap(&base, &tmp_res);
    p /= 2;
  }
  mad_tpsa_mul(base, r, tmp_res);

  // save result and dealloc
  mad_tpsa_copy(tmp_res, orig_res);
  if (base    != orig_res) mad_tpsa_del(base);
  if (r       != orig_res) mad_tpsa_del(r);
  if (tmp_res != orig_res) mad_tpsa_del(tmp_res);
}
#endif // UNUSED

#undef TRACE
#undef T
#undef D
#endif
