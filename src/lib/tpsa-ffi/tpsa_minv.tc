#ifndef TPSA_MINV_TEMPLATE
#define TPSA_MINV_TEMPLATE

#include <gsl/gsl_linalg.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_permutation.h>

#define T struct tpsa
#define D struct tpsa_desc

// --- LOCAL FUNCTIONS --------------------------------------------------------

static inline void
split_and_inv(int nv, const T *ma[nv], T *lin_inv[nv], T *nonlin[nv], int pi[])
{
  assert(ma && lin_inv && nonlin);
  gsl_matrix *mat_lin = gsl_matrix_alloc(nv,nv),
             *mat_inv = gsl_matrix_alloc(nv,nv);

  for (int i = 0; i < nv; ++i) {
    assert(bget(ma[i]->nz,1));   // row cannot be 0
    for (int v = 0; v < nv; ++v)
      gsl_matrix_set(mat_lin, i,v, ma[i]->coef[v+1]);

    for (int o = 2; o <= ma[i]->mo; ++o)
      if (bget(ma[i]->nz,o))
        for (int c = pi[o]; c < pi[o+1]; ++c)
          mad_tpsa_seti(nonlin[i], c, -1 * ma[i]->coef[c]);
  }

  // invert linear part
  gsl_permutation *p = gsl_permutation_alloc(nv);
  int signum;
  gsl_linalg_LU_decomp(mat_lin, p, &signum);
  gsl_linalg_LU_invert(mat_lin, p, mat_inv);
  gsl_permutation_free(p);

  for (int i = 0; i < nv; ++i)
  for (int j = 0; j < nv; ++j)
    mad_tpsa_seti(lin_inv[i], j+1, gsl_matrix_get(mat_inv,i,j));
  gsl_matrix_free(mat_lin);
  gsl_matrix_free(mat_inv);
}

// --- PUBLIC FUNCTIONS -------------------------------------------------------

void
mad_tpsa_minv(int sa, const T *ma[sa], int sc, T *mc[sc])
{
  assert(ma && mc);
  ensure(sa == sc);
  check_same_desc(sa,ma,sc,mc);

  D *d = ma[0]->desc;
  T *lin_inv[sa], *nonlin[sa], *tmp[sa];
  for (int i = 0; i < sa; ++i) {
    lin_inv[i] = mad_tpsa_newd(d);
    nonlin[i]  = mad_tpsa_newd(d);
    tmp[i]     = mad_tpsa_newd(d);
  }

  split_and_inv(sa, ma, lin_inv, nonlin, d->hpoly_To_idx);

  for (int i = 0; i < sa; ++i)
    mad_tpsa_copy(lin_inv[i], mc[i]);

  // iteratively compute higher orders of the inverse
  // MC (OF ORDER I) = AL^-1 o [ I - ANL (NONLINEAR) o MC (OF ORDER I) ]

  for (int o = 2; o <= d->mo; ++o) {
    d->trunc = o;
    mad_tpsa_compose(sa, (const T**)nonlin,  sa, (const T**)mc,  sa, tmp);

    for (int v = 0; v < sa; ++v)
      mad_tpsa_seti(tmp[v], v+1, tmp[v]->coef[v+1] + 1);    // add I

    mad_tpsa_compose(sa, (const T**)lin_inv, sa, (const T**)tmp, sa, mc);
  }

  // cleanup
  for (int i = 0; i < sa; ++i) {
    mad_tpsa_del(lin_inv[i]);
    mad_tpsa_del(nonlin[i]);
    mad_tpsa_del(tmp[i]);
  }
}

void
mad_tpsa_pminv(int sa, const T *ma[sa], int sc, T *mc[sc], int row_select[sa])
{
  assert(ma && mc);
  check_same_desc(sa,ma,sc,mc);

  D *d = ma[0]->desc;
  // split input map into rows that are inverted and rows that are not
  T *mUsed[sa], *mUnused[sa], *mInv[sa];
  for (int i = 0; i < sa; ++i) {
    mUsed  [i] = mad_tpsa_newd(d);
    mUnused[i] = mad_tpsa_newd(d);
    mInv   [i] = mad_tpsa_newd(d);

    if (row_select[i]) {
      mad_tpsa_copy(ma[i],mUsed[i]);
      mad_tpsa_seti(mUnused[i], i+1, 1.0);
    }
    else {
      mad_tpsa_seti(mUsed[i], i+1, 1.0);
      mad_tpsa_copy(ma[i],mUnused[i]);
    }
    mad_tpsa_seti(mUsed  [i],0,0.0);
    mad_tpsa_seti(mUnused[i],0,0.0);
  }

  mad_tpsa_minv(sa,(const T**)mUsed,sa,mInv);
  mad_tpsa_compose(sa,(const T**)mUnused,sa,(const T**)mInv,sc,mc);

  for (int i = 0; i < sa; ++i) {
    mad_tpsa_del(mUsed[i]);
    mad_tpsa_del(mUnused[i]);
    mad_tpsa_del(mInv[i]);
  }
}

#undef T
#undef D
#endif
