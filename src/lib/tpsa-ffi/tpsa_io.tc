#ifndef TPSA_IO_TEMPLATE
#define TPSA_IO_TEMPLATE

// --- LOCAL FUNCTIONS -------------------------------------------------------

static inline void
read_ords(int n, ord_t ords[n], FILE *stream)
{
  assert(ords && stream);
  for (int i = 0; i < n; ++i)
    ensure(fscanf(stream, "%hhu", ords+i) == 1);
}

static inline void
print_ords(int n, ord_t ords[n], FILE *stream)
{
  assert(ords && stream);
  for (int i = 0; i+1 < n; i += 2)
    fprintf(stream, "  %hhu %hhu", ords[i], ords[i+1]);
  if (n % 2)
    fprintf(stream, "  %hhu"     , ords[n-1]);
}

static inline void
read_header(T *t, FILE *stream)
{
  assert(t && stream);
  char buf[50];
  // 1st line -- discarded (empty)
  ensure(fgets(buf, 50, stream));

  struct tpsa_desc *d = t->desc;
  ord_t mo, ords[d->nv], ko;
  int rk, nv, read_cnt = 0;

  // 2nd line
  read_cnt = fscanf(stream, "%*11c, NO =%5hhu, NV =%5d, RNK =%5d, KO =%5hhu\n ORDS: ",
                    &mo, &nv, &rk, &ko);
  ensure(fgets(buf, 50, stream));
  if (read_cnt < 2) {
    printf("ERROR WHILE READING TPSA HEADER: Could not read (NO,NV)\n");
    return;
  }

  // 3rd line
  if (read_cnt == 4) {             // GTPSA -- process 3rd line
    read_cnt = fscanf(stream, " ORDS: ");
    printf("GTPSA read_cnt=%d\n", read_cnt);
    ensure(!feof(stream) && !ferror(stream));
    read_ords(nv,ords,stream);
  }
  else if (read_cnt == 2) {        // TPSA  -- ignore  3rd line; default values
    rk = nv; ko = 0;
    mono_set(nv,ords,mo);
  }
  else {
    printf("ERROR WHILE READING TPSA HEADER: Could not read KO\n");
    return;
  }
  ensure(fgets(buf, 50, stream));  // finish 3rd line

  // discard extra lines
  ensure(fgets(buf, 50, stream));
  ensure(fgets(buf, 50, stream));

  ensure(d == get_desc(nv,ords,mo,rk,ko));  // consistency check
}

// --- PUBLIC FUNCTIONS -------------------------------------------------------

void
mad_tpsa_read(T *t, FILE *stream_)
{
  assert(t);

  if (!stream_)
    stream_ = stdin;
  read_header(t,stream_);

  num_t c;
  int nv = t->desc->nv;
  ord_t o, ords[nv];
  mad_tpsa_clean(t);
  while (fscanf(stream_, "%*d %21lG %hhu", &c, &o) == 2) {
    read_ords(nv,ords,stream_);
    ensure(mono_sum(nv,ords) == o);  // consistency check
    if (o > t->to)  // TODO: give warning ?
      break;        // printed by increasing orders
    mad_tpsa_setm(t,nv,ords,c);
  }
}

void
mad_tpsa_print(const T *t, FILE *stream_)
{
  assert(t);

  if (!stream_)
    stream_ = stdout;
  D *d = t->desc;

  // print header
  char name[11] = "-UNNAMED--";
  fprintf(stream_, "\n %10s, NO =%5d, NV =%5d, RNK =%5d, KO =%5hhu\n ORDS: ",
          name,d->mo,d->nv,d->knb_start,d->ko);
  print_ords(d->nv,d->a,stream_);
  fprintf(stream_, "\n *******************************************************");

  if (!t->nz) {
    fprintf(stream_, "\n   ALL COMPONENTS ZERO \n");
    return;
  }

  fprintf(stream_, "\n    I  COEFFICIENT          ORDER   EXPONENTS");
  int idx = 1;
  for (int c = 0; c < d->nc; ++c)
    if (bget(t->nz,d->ords[c]) && fabs(t->coef[c]) > 1e-10) {
      fprintf(stream_, "\n%6d  %21.14lE%5hhu   ", idx, t->coef[c], d->ords[c]);
      print_ords(d->nv, d->To[c], stream_);
      idx++;
    }
  fprintf(stream_, "\n\n");
}

#undef TRACE

#undef T
#undef D


#endif
