#ifndef TPSA_IO_TEMPLATE
#define TPSA_IO_TEMPLATE

#define T struct tpsa
#define D struct tpsa_desc

// #define TRACE
// #define DEBUG

// --- LOCAL FUNCTIONS -------------------------------------------------------

static inline void
read_ords(int n, ord_t ords[n], FILE *stream)
{
  assert(ords && stream);
  for (int i = 0; i < n; ++i)
    ensure(fscanf(stream, "%hhu", ords+i) == 1);
}

static inline void
print_ords(int n, ord_t ords[n], FILE *stream)
{
  assert(ords && stream);
  for (int i = 0; i+1 < n; i += 2)
    fprintf(stream, "  %hhu %hhu", ords[i], ords[i+1]);
  if (n % 2)
    fprintf(stream, "  %hhu"     , ords[n-1]);
}

// --- PUBLIC FUNCTIONS -------------------------------------------------------

D*
mad_tpsa_desc_read(FILE *stream_)
{
#ifdef TRACE
  printf("tpsa_desc_read from %p\n", (void*)stream_);
#endif
  if (!stream_)
    stream_ = stdin;

  const int BUF_SIZE = 100;
  char buf[BUF_SIZE];
  // 1st line -- discarded (empty)
  ensure(fgets(buf, BUF_SIZE, stream_));

  ord_t mo, ko;
  int ncv, nk = 0, read_cnt = 0;

  // 2nd line
  read_cnt = fscanf(stream_, "%*11c, NO =%5hhu, NV =%5d, KO =%5hhu, NK =%5d",
                    &mo, &ncv, &ko, &nk);
  ensure(fgets(buf, BUF_SIZE, stream_));
  if (read_cnt < 2) {
    printf("ERROR WHILE READING TPSA HEADER: Could not read (NO,NV)\n");
    return NULL;
  }
  else if (read_cnt == 3) {
    printf("ERROR WHILE READING TPSA HEADER: Could not read NK\n");
    return NULL;
  }

  // 3rd line
  ord_t ords[ncv+nk];
  if (read_cnt == 4) {             // GTPSA -- process 3rd line
    read_cnt = fscanf(stream_, " ORDS: ");
    ensure(!feof(stream_) && !ferror(stream_));
    read_ords(ncv+nk,ords,stream_);
  }
  else if (read_cnt == 2) {        // TPSA  -- ignore  3rd line; default values
    nk = ko = 0;
    mono_set(ncv,ords,mo);
  }
  ensure(fgets(buf, BUF_SIZE, stream_));  // finish 3rd line

  // discard extra lines
  ensure(fgets(buf, BUF_SIZE, stream_));
  ensure(fgets(buf, BUF_SIZE, stream_));

  return get_desc(ncv+nk,ords,mo,ncv,ko);
}

void
mad_tpsa_read_coef(T *t, FILE *stream_)
{
#ifdef TRACE
  printf("tpsa_read from %p\n", (void*)stream_);
#endif
  ensure(t);

  if (!stream_)
    stream_ = stdin;

  num_t c;
  int nv = t->desc->nv, read_cnt = -1;
  ord_t o, ords[nv];
  mad_tpsa_clean(t);
  while ((read_cnt = fscanf(stream_, "%*d %21lG %hhu", &c, &o)) == 2) {
    #ifdef DEBUG
      printf("cnt=%d c=%.2f o=%d\n", read_cnt, c, o);
    #endif
    read_ords(nv,ords,stream_);
    ensure(mono_sum(nv,ords) == o);  // consistency check
    if (o > t->to)  // TODO: give warning ?
      break;        // printed by increasing orders
    mad_tpsa_setm(t,nv,ords,c);
  }
}

void
mad_tpsa_print(const T *t, FILE *stream_)
{
  assert(t);

  if (!stream_)
    stream_ = stdout;
  D *d = t->desc;

  // print header
  char name[11] = "-UNNAMED--";
  fprintf(stream_, "\n %10s, NO =%5hhu, NV =%5d, KO =%5hhu, NK =%5d\n ORDS: ",
          name,d->mo,d->knb_start,d->ko, d->nv - d->knb_start);
  print_ords(d->nv,d->a,stream_);
  fprintf(stream_, "\n *******************************************************");

  if (!t->nz) {
    fprintf(stream_, "\n   ALL COMPONENTS ZERO \n");
    return;
  }

  fprintf(stream_, "\n    I  COEFFICIENT          ORDER   EXPONENTS");
  int idx = 1;
  for (int c = 0; c < d->nc; ++c)
    if (bget(t->nz,d->ords[c]) && fabs(t->coef[c]) > 1e-10) {
      fprintf(stream_, "\n%6d  %21.14lE%5hhu   ", idx, t->coef[c], d->ords[c]);
      print_ords(d->nv, d->To[c], stream_);
      idx++;
    }
  fprintf(stream_, "\n\n");
}

#undef TRACE
#undef DEBUG

#undef T
#undef D

#endif  // TPSA_IO_TEMPLATE
