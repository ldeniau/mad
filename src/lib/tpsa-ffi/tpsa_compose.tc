#ifndef TPSA_COMPOSE_TEMPLATE
#define TPSA_COMPOSE_TEMPLATE

#define T struct tpsa
#define D struct tpsa_desc

struct compose_ctx {
  int sa;
  char *required;
  const T **ma, **mb;
        T **mc, **tmps;
  D *da;
};

static inline void
check_same_desc(int sa, const T *ma[sa], int sc, T *mc[sc])
{
  assert(ma && mc);
  assert(ma[0]->desc == mc[0]->desc);
  for (int i = 1; i < sa; ++i) assert(ma[i]->desc == ma[i-1]->desc);
  for (int i = 1; i < sc; ++i) assert(mc[i]->desc == mc[i-1]->desc);
}

static inline void
check_compose(int sa, const T *ma[], int sb, const T *mb[], int sc, T *mc[])
{
  assert(ma && mb && mc);
  assert(sa && sb && sc);
  assert(sa == sc);
  assert(sb == ma[0]->desc->knb_start);
  check_same_desc(sa,ma,sc,mc);
  check_same_desc(sb,mb,sc,mc);
}

static inline void
compose(int pos, ord_t o, ord_t curr_mono[], struct compose_ctx *ctx)
{
  D *da = ctx->da;
  int idx = desc_get_idx(da, da->nv, curr_mono);
  if (!ctx->required[idx])
    return;

  if (o > 0)
    mad_tpsa_mul(ctx->tmps[o-1], ctx->mb[pos], ctx->tmps[o]);

  double coef_val;
  const T **ma = ctx->ma;
  for (int i = 0; i < ctx->sa; ++i) {
    coef_val = 0;
    // sum up all knobs
    do {
      idx = desc_get_idx(da, da->nv, curr_mono);
      if (bget(ma[i]->nz, da->ords[idx]))
        coef_val += ma[i]->coef[idx];
    } while (nxt_mono_by_var(da,da->nv,curr_mono,da->knb_start));

    if (coef_val)
      mad_tpsa_axpb(coef_val, ctx->tmps[o], ctx->mc[i], ctx->mc[i]);
  }

  // reset knobs
  for (int k = da->knb_start; k < da->nv; ++k)
    curr_mono[k] = 0;

  for(  ; pos < da->knb_start; ++pos) {
    curr_mono[pos]++;
    if (desc_mono_isvalid(da, da->nv, curr_mono))
      compose(pos, o+1, curr_mono, ctx);
    curr_mono[pos]--;
  }
}

static inline void
init_required(int sa, const T *ma[sa], char required[])
{
  assert(ma && required);
  D *d = ma[0]->desc;
  int nv = d->nv, max_mo = -1, *pi = d->hpoly_To_idx;
  double eps = 1e-10;

  // original nodes
  memset(required, 0, d->nc);
  for (int i = 0; i < sa; ++i) {
    if (ma[i]->mo > max_mo)
      max_mo = ma[i]->mo;
    for (int c = 0; c < pi[ ma[i]->mo+1 ]; ++c)
      if (bget(ma[i]->nz,d->ords[c]) &&
         (ma[i]->coef[c] < -eps || ma[i]->coef[c] > eps)) // != 0
        required[c] = 1;
  }

  // truncate
  for (int c = pi[d->trunc+1]; c < pi[max_mo+1]; ++c)
    required[c] = 0;

  // root is always required
  required[0] = 1;

  // fathers of nodes
  ord_t *mono = NULL;
  int j, father = -1;
  for (int o = min_ord(max_mo,d->trunc); o > 1; --o) {
    for (int c = pi[o]; c < pi[o+1]; ++c)
      if (required[c]) {
        mono = d->To[c];
        for (j = nv-1; j >= 0 && !mono[j]; --j)
          ; // get j to first non-zero element
        mono[j]--;
        father = desc_get_idx(d, nv, mono);
        mono[j]++;
        required[father] = 1;
      }
  }
}

void
mad_tpsa_compose(int sa, const T *ma[], int sb, const T *mb[], int sc, T *mc[])
{
#ifdef TRACE
  printf("tpsa_compose\n");
#endif
  check_compose(sa, ma, sb, mb, sc, mc);

  // locals
  D *da = ma[0]->desc;
  ord_t mono[da->nv];
  T *tmps[da->mo+2];
  char required[da->nc];

  // initialization
  init_required(sa, ma, required);
  for (int v = 0; v < da->nv  ; ++v) mono[v] = 0;
  for (int o = 0; o < da->mo+2; ++o) tmps[o] = mad_tpsa_newd(da);
  mad_tpsa_seti(tmps[1], 0, 1.0);
  for (int ic = 0; ic < sc; ++ic)
    mad_tpsa_clean(mc[ic]);

  struct compose_ctx ctx = { .sa=sa, .ma=ma,   .mc=mc,  .required=required,
                             .da=da, .mb=mb, .tmps=tmps+1  };

  compose(0, 0, mono, &ctx);

  // cleanup
  for (int o = 0; o < da->mo+2; ++o) mad_tpsa_del(tmps[o]);
}

void
mad_tpsa_compose_slow(int sa, const T *ma[], int sb, const T *mb[], int sc, T *mc[])
{
#ifdef TRACE
  printf("tpsa_compose\n");
#endif
  assert(ma && mb && mc);
  assert(ma[0]->desc->knb_start == sb);
  (void)sc;

  for (int ic = 0; ic < sc; ++ic)
    mad_tpsa_clean(mc[ic]);

  D *desc_a = ma[0]->desc;
  ord_t *curr_mono;
  T *curr_build = mad_tpsa_new(ma[0]), *tmp_res = mad_tpsa_new(ma[0]);
  int coef_lim;
  for (int ia = 0; ia < sa; ++ia) {
    ord_t mo = min_ord(ma[ia]->mo, desc_a->trunc);
    coef_lim = desc_a->hpoly_To_idx[mo+1];

    for (int mono_idx = 0; mono_idx < coef_lim; ++mono_idx) {
      curr_mono = desc_a->To[mono_idx];

      mad_tpsa_clean(curr_build);
      num_t curr_coef = mad_tpsa_geti(ma[ia], mono_idx);
      if (curr_coef == 0)
        continue;

      mad_tpsa_seti(curr_build, 0, curr_coef);
      for (int var = 0; var < desc_a->knb_start; ++var)
        for (ord_t o = 0; o < curr_mono[var]; ++o) { // pow
          mad_tpsa_mul(curr_build, mb[var], tmp_res);
          mad_tpsa_copy(tmp_res, curr_build);
        }

      mad_tpsa_add(mc[ia], curr_build, tmp_res);
      mad_tpsa_copy(tmp_res, mc[ia]);
    }
  }
}

#undef T
#undef D
#endif
