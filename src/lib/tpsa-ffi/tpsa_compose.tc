#ifndef TPSA_COMPOSE_TEMPLATE
#define TPSA_COMPOSE_TEMPLATE

// #define TRACE

#define T struct tpsa
#define D struct tpsa_desc

struct compose_ctx {
  int sa;
  char *required;
  const T **ma, **mb;
        T **mc, **ords, *knb_coef, *tmp;
  D *da;
};

// --- LOCAL FUNCTIONS --------------------------------------------------------

static inline void
check_same_desc(int sa, const T *ma[sa], int sc, T *mc[sc])
{
  assert(ma && mc);
  ensure(ma[0]->desc == mc[0]->desc);
  for (int i = 1; i < sa; ++i) ensure(ma[i]->desc == ma[i-1]->desc);
  for (int i = 1; i < sc; ++i) ensure(mc[i]->desc == mc[i-1]->desc);
}

static inline void
check_compose(int sa, const T *ma[], int sb, const T *mb[], int sc, T *mc[])
{
  assert(ma && mb && mc);
  ensure(sa && sb && sc);
  ensure(sa == sc);
  ensure(sb == ma[0]->desc->knb_start);
  check_same_desc(sa,ma,sc,mc);
  check_same_desc(sb,mb,sc,mc);
}

static inline T*
get_knobs_coef(const T* a, int idx, const ord_t pure_mono[], struct compose_ctx *ctx)
{
  // extract from `a` all knob children of `idx`
  assert(pure_mono && ctx);
  D *d = ctx->da;
  ord_t mono[d->nv], knb_mono[d->nv];
  mono_cpy(d->nv, pure_mono, mono);
  num_t val;
  mad_tpsa_clean(ctx->knb_coef);

  do {
    idx = desc_get_idx(d, d->nv, mono);
    val = mad_tpsa_geti(a,idx);
    if (val) {
      mono_cpy(d->nv, mono, knb_mono);
      mono_set(d->knb_start, knb_mono, 0);
      int idx_knb_only = desc_get_idx(d, d->nv, knb_mono);
      mad_tpsa_seti(ctx->knb_coef, idx_knb_only, val);
    }
  } while(nxt_mono_by_var(d, d->nv, mono, d->knb_start));

  return ctx->knb_coef;
}

static inline void
compose(int pos, ord_t o, ord_t curr_mono[], struct compose_ctx *ctx)
{
  D *da = ctx->da;
  int idx = desc_get_idx(da, da->nv, curr_mono);
  if (!ctx->required[idx])
    return;

  if (o > 0)
    mad_tpsa_mul(ctx->ords[o-1], ctx->mb[pos], ctx->ords[o]);

  if (da->knb_start < da->nv) { // there are knobs
    for (int i = 0; i < ctx->sa; ++i) {
      T *coef = get_knobs_coef(ctx->ma[i], idx, curr_mono, ctx);
      if (coef->nz) {
        mad_tpsa_mul(coef    , ctx->ords[o], ctx->tmp);
        mad_tpsa_add(ctx->tmp, ctx->mc[i]  , ctx->mc[i]);
      }
    }
  }
  else {                        // no knobs
    for (int i = 0; i < ctx->sa; ++i) {
      num_t coef = mad_tpsa_geti(ctx->ma[i],idx);
      if (coef) {
        mad_tpsa_scale(coef    , ctx->ords[o], ctx->tmp);
        mad_tpsa_add  (ctx->tmp, ctx->mc[i]  , ctx->mc[i]);
      }
    }
  }

  for(  ; pos < da->knb_start; ++pos) {  // don't put knobs in curr_mono
    curr_mono[pos]++;
    if (desc_mono_isvalid(da, da->nv, curr_mono))
      compose(pos, o+1, curr_mono, ctx);
    curr_mono[pos]--;
  }
}

static inline void
init_required(int sa, const T *ma[sa], char required[])
{
  assert(ma && required);
  D *d = ma[0]->desc;
  int nv = d->nv, max_mo = -1, *pi = d->hpoly_To_idx;
  double eps = 1e-10;

  // original nodes
  memset(required, 0, d->nc);
  for (int i = 0; i < sa; ++i) {
    if (ma[i]->mo > max_mo)
      max_mo = ma[i]->mo;
    for (int c = 0; c < pi[ ma[i]->mo+1 ]; ++c)
      if (   bget(ma[i]->nz,d->ords[c])
          && mono_sum(d->knb_start,d->To[c]) <= d->trunc
          && (ma[i]->coef[c] < -eps || ma[i]->coef[c] > eps)) // != 0
        required[c] = 1;
  }

  // root is always required
  required[0] = 1;

  // fathers of nodes
  ord_t mono[nv];
  int j, father = -1;
  for (int o = min_ord(max_mo,d->trunc); o > 1; --o) {
    for (int c = pi[o]; c < pi[o+1]; ++c)
      if (required[c]) {
        mono_cpy(nv,d->To[c],mono);
        for (j = nv-1; j >= 0 && !mono[j]; --j)
          ; // get j to first non-zero element
        mono[j]--;
        father = desc_get_idx(d,nv,mono);
        required[father] = 1;
      }
  }
}

// --- PUBLIC FUNCTIONS -------------------------------------------------------

void
mad_tpsa_compose(int sa, const T *ma[], int sb, const T *mb[], int sc, T *mc[])
{
#ifdef TRACE
  printf("tpsa_compose\n");
#endif
  check_compose(sa, ma, sb, mb, sc, mc);

  // locals
  D *da = ma[0]->desc;
  ord_t mono[da->nv];
  T *ords[da->mo+1];  // one for each order [0,mo]
  char required[da->nc];

  // initialization
  init_required(sa, ma, required);
  for (int v = 0; v <  da->nv; ++v) mono[v] = 0;
  for (int o = 0; o <= da->mo; ++o) ords[o] = mad_tpsa_newd(da);
  mad_tpsa_seti(ords[0], 0, 1.0);
  for (int ic = 0; ic < sc; ++ic)
    mad_tpsa_clean(mc[ic]);

  struct compose_ctx ctx = { .sa=sa, .ma=ma,   .mc=mc,  .required=required,
                             .da=da, .mb=mb, .ords=ords  };
  ctx.knb_coef = mad_tpsa_newd(da);
  ctx.tmp      = mad_tpsa_newd(da);

  // do composition from root of tree, ord 0
  compose(0, 0, mono, &ctx);

  // cleanup
  for (int o = 0; o <= da->mo; ++o)
    mad_tpsa_del(ords[o]);
  mad_tpsa_del(ctx.knb_coef);
  mad_tpsa_del(ctx.tmp);
}

void
mad_tpsa_compose_slow(int sa, const T *ma[], int sb, const T *mb[], int sc, T *mc[])
{
#ifdef TRACE
  printf("tpsa_compose\n");
#endif
  assert(ma && mb && mc);
  assert(ma[0]->desc->knb_start == sb);
  (void)sc;

  for (int ic = 0; ic < sc; ++ic)
    mad_tpsa_clean(mc[ic]);

  D *desc_a = ma[0]->desc;
  ord_t *curr_mono;
  T *curr_build = mad_tpsa_new(ma[0]), *tmp_res = mad_tpsa_new(ma[0]);
  int coef_lim;
  for (int ia = 0; ia < sa; ++ia) {
    ord_t mo = min_ord(ma[ia]->mo, desc_a->trunc);
    coef_lim = desc_a->hpoly_To_idx[mo+1];

    for (int mono_idx = 0; mono_idx < coef_lim; ++mono_idx) {
      curr_mono = desc_a->To[mono_idx];

      mad_tpsa_clean(curr_build);
      num_t curr_coef = mad_tpsa_geti(ma[ia], mono_idx);
      if (curr_coef == 0)
        continue;

      mad_tpsa_seti(curr_build, 0, curr_coef);
      for (int var = 0; var < desc_a->knb_start; ++var)
        for (ord_t o = 0; o < curr_mono[var]; ++o) { // pow
          mad_tpsa_mul(curr_build, mb[var], tmp_res);
          mad_tpsa_copy(tmp_res, curr_build);
        }

      mad_tpsa_add(mc[ia], curr_build, tmp_res);
      mad_tpsa_copy(tmp_res, mc[ia]);
    }
  }
}

#undef T
#undef D
#endif
