#ifndef TPSA_COMPOSE_TEMPLATE
#define TPSA_COMPOSE_TEMPLATE

#include <omp.h>

#define MAX_CACHED_ORDS 4
// #define DEBUG

struct compose_ctx {
  int cached_size;
  D *d;
  T **cached;
};

#define CTX struct compose_ctx

static inline void
check_compose(int sa, const T *ma[], int sb, const T *mb[], int sc, T *mc[])
{
  assert(ma && mb && mc);
  assert(sa && sb && sc);
  assert(sa == sc);
  assert(sb == ma[0]->desc->nv);
  for (int i = 1; i < sa; ++i) {
    assert(ma[i]->desc == ma[i-1]->desc);
    assert(ma[i]->desc == mc[i]->desc);
  }
  for (int i = 1; i < sb; ++i)
    assert(mb[i]->desc == mb[i-1]->desc);
}

static inline int
init_required(int sa, const T *ma[sa], char required[])
{
  assert(ma && required);
  D *d = ma[0]->desc;
  int *pi = d->hpoly_To_idx, max_mo = -1;
  double eps = 1e-10;
  memset(required, 0, d->nc);
  for (int i = 0; i < sa; ++i) {
    if (ma[i]->mo > max_mo)
      max_mo = ma[i]->mo;

    for (int c = 0; c < pi[ ma[i]->mo+1 ]; ++c)
      if (ma[i]->coef[c] < -eps || ma[i]->coef[c] > eps) // != 0
        required[c] = 1;
  }
  return max_mo;
}

static inline T*
get_mono(int c, int tmp_idx, T *tmps[2], ord_t complement[], CTX *ctx)
{
  if (c < ctx->cached_size && ctx->cached[c])
    return ctx->cached[c];

  D *d = ctx->d;
  T **cached = ctx->cached;

  for (int m = ctx->cached_size - 1; m > 0; --m)
    if (cached[m] && mono_leq(d->nv, d->To[m], d->To[c])) {
      mono_sub(d->nv, d->To[c], d->To[m], complement);
      int compl_idx = desc_get_idx(d, d->nv, complement);
      T *t = get_mono(compl_idx, tmp_idx ^ 1, tmps, complement, ctx);

#ifdef DEBUG
      mono_print(da->nv, da->To[c]);
      printf(" = ");
      mono_print(da->nv, da->To[m]);
      mono_print(da->nv, da->To[compl_idx]);
      printf("m=%d", m);
      printf("\n");
#endif

      mad_tpsa_mul(t, cached[m], tmps[tmp_idx]);
      break;
    }

  // update cache if needed
  if (c < ctx->cached_size) {
    assert(!cached[c]);             // no double alloc
    cached[c] = mad_tpsa_newd(d);
    mad_tpsa_copy(tmps[tmp_idx], cached[c]);
  }
  return tmps[tmp_idx];
}

static inline void
sequential_compose(int sa, const T *ma[], T *mc[], CTX *ctx)
{
  assert(ma && mc && ctx);

  // cleanup & ord 0
  for (int i = 0; i < sa; ++i) {
    mad_tpsa_clean(mc[i]);
    mad_tpsa_seti(mc[i], 0, ma[i]->coef[0]);
  }

  ord_t mono[ctx->d->nv];
  T *tmps[2] = { mad_tpsa_newd(ctx->d), mad_tpsa_newd(ctx->d) }, *t;
  for (int c = 1; c < ctx->cached_size; ++c) {
    // TODO: only cache what is needed
    t = get_mono(c, 0, tmps, mono, ctx);
    for (int i = 0; i < sa; ++i)
      if (ma[i]->coef[c])
        mad_tpsa_cma(ma[i]->coef[c], t, mc[i], mc[i]);
  }
  mad_tpsa_del(tmps[0]);
  mad_tpsa_del(tmps[1]);
}

void
mad_tpsa_compose(int sa, const T *ma[], int sb, const T *mb[], int sc, T *mc[])
{
#ifdef TRACE
  printf("tpsa_compose\n");
#endif
  check_compose(sa, ma, sb, mb, sc, mc);

  // locals
  D *da = ma[0]->desc;
  char required[da->nc];
  int nv = da->nv, *pi = da->hpoly_To_idx;       // local names

  // init
  int max_mo = init_required(sa, ma, required);

  ord_t to_cache = da->mo < MAX_CACHED_ORDS ? da->mo : MAX_CACHED_ORDS;
  int cached_size = pi[to_cache+1];
  T *cached[cached_size], *t = NULL;

  /* cached[0] not in use --> */              cached[0] = NULL;
  for (int c =      1; c <= nv         ; ++c) cached[c] = (T *) mb[c-1];
  for (int c = nv + 1; c <  cached_size; ++c) cached[c] = NULL;

  CTX ctx = { .d = da, .cached_size = cached_size, .cached = cached };

  // compose
  sequential_compose(sa, ma, mc, &ctx);

  // ords MAX_CACHED_ORDS..max_mo
  const int threads = 2;
  T *mr[threads][sc];
  #pragma omp parallel private(mc) num_threads(threads)
  {
    int id = omp_get_thread_num();

    // alloc private vars
    ord_t mono[nv];
    T *tmps[2];
    tmps[0] = mad_tpsa_newd(mb[0]->desc);
    tmps[1] = mad_tpsa_newd(mb[0]->desc);
    mc = mr[id];
    for (int i = 0; i < sc; ++i) {
      mc[i] = mad_tpsa_newd(da);
      assert(mc[i]->desc == da);
    }

    #pragma omp for
    for (int c = cached_size; c < pi[max_mo+1]; ++c) {
      if (!required[c])
        continue;

      t = get_mono(c, 0, tmps, mono, &ctx);
      for (int i = 0; i < sa; ++i)
        if (ma[i]->coef[c])
          mad_tpsa_cma(ma[i]->coef[c], t, mc[i], mc[i]);
    }
    mad_tpsa_del(tmps[0]);
    mad_tpsa_del(tmps[1]);
  }

  for (int thread = 0; thread < threads; ++thread)
    for (int i = 0; i < sc; ++i) {
      mad_tpsa_add(mr[thread][i], mc[i], mc[i]);
      mad_tpsa_del(mr[thread][i]);
    }

  // finalize
  for (int c = nv + 1; c < cached_size; ++c)
    mad_tpsa_del(cached[c]);
}

static inline void
mad_tpsa_compose_slow(int sa, const T *ma[], int sb, const T *mb[], int sc, T *mc[])
{
#ifdef TRACE
  printf("tpsa_compose\n");
#endif
  assert(ma && mb && mc);
  assert(ma[0]->desc->nv == sb);
  (void)sc;

  D *desc_a = ma[0]->desc;
  ord_t *curr_mono;
  T *curr_build = mad_tpsa_new(ma[0]), *tmp_res = mad_tpsa_new(ma[0]);
  int nv = desc_a->nv, coef_lim;
  for (int ia = 0; ia < sa; ++ia) {
    coef_lim = desc_a->hpoly_To_idx[ma[ia]->mo + 1];

    for (int mono_idx = 0; mono_idx < coef_lim; ++mono_idx) {
      curr_mono = desc_a->To[mono_idx];

      mad_tpsa_clean(curr_build);
      num_t curr_coef = mad_tpsa_geti(ma[ia], mono_idx);
      if (curr_coef == 0)
        continue;

      mad_tpsa_seti(curr_build, 0, curr_coef);
      for (int cmi = 0; cmi < nv; ++cmi)
        for (ord_t o = 0; o < curr_mono[cmi]; ++o) { // pow
          mad_tpsa_mul(curr_build, mb[cmi], tmp_res);
          mad_tpsa_copy(tmp_res, curr_build);
        }

      mad_tpsa_add(mc[ia], curr_build, tmp_res);
      mad_tpsa_copy(tmp_res, mc[ia]);
    }
  }
}

#undef MAX_CACHED_ORDS
#undef CTX

#endif
