
Data structure
==============

Descriptor
----------

struct tpsa_desc {
  int      rk, nv, nc,// number of map vars, number of all vars, number of coeff
           size;      // bytes used by current desc
  ord_t    mo, ko,    // maximum orders: for vars, for knobs
           trunc,     // truncation order for operations
          *a,         // alphas (max order for each var)
          *monos,     // 'matrix' storing the monomials (sorted by ord)
          *ords,      // order of each mono of To
         **To,        // Table by orders -- pointers to monos, sorted by order
         **Tv;        // Table by vars   -- pointers to monos, sorted by vars
  idx_t   *hpoly_To_idx,  // poly start in To
          *tv2to, *to2tv, // lookup tv->to, to->tv
          *H,         // indexing matrix, in Tv
         **L;         // multiplication indexes -- L[oa][ob] = lc; lc[ia][ib] = ic
};



TPSA
-------------

struct tpsa { // warning: must be kept identical to LuaJit definition
  D      *desc;
  ord_t   mo, to; // max ord, trunc ord
  bit_t   nz;
  num_t   coef[];
};

desc -- pointer to a shared descriptor; immutable

to   -- truncation order; immutable
     -- 1 <= to <= desc->mo
     -- coefficients are only allocated up to this polynomial, inclusive
     -- writing or reading an index from a higher order results in error

mo   -- state of current maximum order
     -- modifies according to operations performed on tpsa
     -- used to avoid un-necessary computation
     -- IMPORTANT: 1 <= mo <= to

nz   -- state of non-zero polynomials
     -- used to avoid computation on unused polynomials
     -- type: bit-array; each bit corresponds 1-to-1 to an order
     -- to be used through functions in utils: bset, bget, bclr, badd, btrunc
     -- note: when clearing ord 0, also set coef[0] = 0 because ord0 is not checked
        when performing computations


Constructor
===========

Descriptor
----------
a) without knobs:
D*    mad_tpsa_desc_new  (int nv, const ord_t var_ords[nv], ord_t vo)
    -- var_ords[i] <= mo

b) with knobs:
D*    mad_tpsa_desc_newk (int nv, const ord_t var_ords[nv], ord_t vo,
                          int nk, const ord_t knb_ords[nk], ord_t ko);
    -- vo in [max(var_ords), sum(var_ords)]
    -- ko in [max(knb_ords), sum(knb_ords)]
    -- vo >= ko
    -- EXCEPTIONS: var_ords= { 2, 2, 2, 2, 0, 0 }

TPSA
----
a) T* mad_tpsa_newd(D *d, const ord_t *trunc_ord_)
    -- allocates a TPSA for the descriptor d, with capacity for orders up to trunc_ord_
    -- if trunc_ord_ is NULL, then d->mo is used

b) T* mad_tpsa_new(const T *t)
    -- allocates a TPSA of the same kind as t (same descriptor, same truncation order)



Operations
===========

Peek & Poke
-----------
void mad_tpsa_setConst(T *t, num_t c)
    -- set t as constant c

A) higher level: based on monomial
----------------------------------

num_t mad_tpsa_getm(const T *t, int n, const ord_t m[n])
    -- gets the value of the coefficient given by the monomial m
    -- n = lenght of monomial m
    -- if n < desc->nv then the rest of m is considered to be filled with 0s
    -- ERROR if the monomial m is outside of the range of t [ ord(m) > t->to ]

void mad_tpsa_setm(T *t, int n, const ord_t m[n], num_t v)
    -- sets the coefficient given by the monomial m to the value of v
    -- same considerations as getm


B) lower level: based on index
----------------------------------
int mad_tpsa_get_idx(const T *t, int n, const ord_t m[n])
    -- get an index associated with the monomial m
    -- if n=len(m) < desc->nv then the rest of m is considered to be filled with 0s
    -- the index may not be valid for the tpsa t (i.e. may be out of range)

num_t mad_tpsa_geti(const T *t, int i)
    -- gets the value of the coefficient at index i
    -- returns 0 if ord(mono(i)) > t->to

num_t mad_tpsa_seti(const T *t, int i, num_t v)
    -- sets the coefficient at index i to value v
    -- ERROR  -- if i is outside of the range of t [ ord(mono(i)) > t->to ]
              -- if i is outside the current truncation order [ desc->trunc ] (should be warning ?)
