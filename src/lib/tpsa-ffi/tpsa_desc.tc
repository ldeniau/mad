#include "mad_tpsa_desc.h"

// #define TRACE
// #define DEBUG

typedef int           idx_t;

#define D struct tpsa_desc

struct tpsa_desc {
  int      nv, nc,    // number of vars, number of coeff
           knb_start, // index in `a` where the knobs start
           size;      // bytes used by current desc
  ord_t    mo, mko,   // maximum order, maximum knob order
          *a,         // alphas
          *monos,     // 'matrix' storing the monomials (sorted by ord)
         **To,        // Table by orders -- pointers to monos, sorted by order
          *ords,      // order of each mono of To
         **Tv;        // Table by vars   -- pointers to monos, sorted by vars
  idx_t   *hpoly_To_idx,  // poly start in To
          *tv2to, *to2tv, // lookup tv->to, to->tv
         **L,         // multiplication indexes -- l[oa][ob] = lc; lc[ia][ib] = ic
          *H;         // indexing matrix
};

// --- HELPERS ----------------------------------------------------------------

static inline int
imin (int a, int b)
{
  return a<b ? a : b;
}

static inline int
imax (int a, int b)
{
  return a>b ? a : b;
}

static inline int
max_nc(int nv, int no)
{
  int max = imax(nv,no), num = 1, den = 1;
  for (int i = max + 1; i <= nv + no; ++i) {
    num *= i;
    den *= i - max;
  }
  return num / den;
}

static inline idx_t
hpoly_idx_triang(idx_t ib, idx_t ia)
{
  return (ia*(ia+1))/2 + ib;  // left triangular
}

static inline idx_t
hpoly_idx_rect(idx_t ib, idx_t ia, int ia_size)
{
  return ib*ia_size + ia;
}


// --- MONOMIALS --------------------------------------------------------------

static inline int
desc_mono_isvalid(const D *d, int n, const ord_t m[n])
{
  assert(d && m);
  return    n <= d->nv
         && mono_sum(        d->knb_start, m               ) <= d->mo
         && mono_sum(d->nv - d->knb_start, m + d->knb_start) <= d->mko
         && mono_leq(d->nv, m, d->a);
}

static inline int
nxt_mono_by_var(D *d, int n, ord_t m[n])
{
  assert(d && m);
  for (int i=0; i < n; ++i) {
    ++m[i];
    if (desc_mono_isvalid(d, n, m))
      return 1;
    m[i] = 0;
  }
  return 0;
}

static inline void
nxt_mono_by_unk(int n, const ord_t a[n], int i, int j, ord_t m[n])
{
  assert(a && m);
  mono_set(n,m,0);
  for (int k=i; k < n; ++k) {
    m[k] = a[k];
    j -= a[k];
    if (j <= 0) {
      if (j < 0) m[k] += j;
      break;
    }
  }
}

static inline void
print_mono_mat(int w, int h, const ord_t t[w*h])
{
  for (int i = 0; i < h; ++i) {
    printf("(%2d) ", i);
    mono_print(w, t + i*w);
    printf("\n");
  }
}

// --- TABLES -----------------------------------------------------------------

static inline void
tbl_print(int w, int h, ord_t **t)
{
  for (int i = 0; i < h; ++i) {
    printf("(%2d) ", i);
    mono_print(w, t[i]);
    printf("\n");
  }
}

static inline void
tbl_realloc_monos(D *d, int new_nc_)
{
  // reallocates array of monomials to fit at least new_nc_ items
  // if new_nc_ is not specified, it increases the capacity of exiting array
  assert(d);

  if (!new_nc_) {
    if (d->nc < (1<<21)) new_nc_ = d->nc * 2;        // double capacity
    else                 new_nc_ = d->nc + (1<<20);  // +1 Mb
  }
#ifdef TRACE
  printf("realloc for nc= %d\n", new_nc_);
#endif
  d->nc = new_nc_;
  d->monos = realloc(d->monos, d->nc * d->nv * sizeof *(d->monos));
  d->ords  = realloc(d->ords,  d->nc         * sizeof *(d->monos));
}

static inline int  // last monomial's index
make_higher_ord_monos(D *d, int curr_mono_idx, int need_realloc)
{
#ifdef TRACE
  printf("make_higher_ord_monos, cmi=%d\n", curr_mono_idx);
#endif

// ords 2..mo
  int nv = d->nv, j;
  ord_t m[nv], *curr_mono = d->monos + curr_mono_idx*nv;
  for (ord_t o = 2; o <= d->mo; o++) {             // to build ord o:
    for (int i = 1; i < d->hpoly_To_idx[2]; ++i) { // i goes through ord    1
      j = d->hpoly_To_idx[o-1];                    // j goes through ord (o-1)
      do {
        mono_add(nv, d->monos + i*nv, d->monos + j*nv, m);
        if (desc_mono_isvalid(d, nv, m)) {
          if (need_realloc && curr_mono_idx >= d->nc) {
            tbl_realloc_monos(d,0);
            curr_mono = d->monos + nv*curr_mono_idx;
          }
          mono_cpy(nv, m, curr_mono);
          d->ords[curr_mono_idx] = o;
          curr_mono_idx++;
          curr_mono += nv;
        }
        j++;
      } while(m[i-1] <= d->a[i-1] && m[i-1] < o && j < d->hpoly_To_idx[o]);
    }
    d->hpoly_To_idx[o+1] = curr_mono_idx;
  }

#ifdef DEBUG
  print_mono_mat(d->nv, imin(curr_mono_idx, 50), d->monos);
  if (curr_mono_idx > 50) printf("... [ %d more rows ] ...\n", curr_mono_idx - 50);
#endif

  return curr_mono_idx;
}

static inline void
make_monos(D *d)
{
  // builds the monomials matrix in To order
#ifdef TRACE
  printf("make_monos for %p\n", (void*)d);
#endif

  assert(d && d->a);
  const int max_init_alloc = 1 << 15;
  d->nc = max_nc(d->nv, d->mo);
  int nv = d->nv, need_realloc = 0;
  if (d->nc > max_init_alloc) {
    need_realloc = 1;
    d->nc = max_init_alloc;
  }

  d->monos        = malloc(d->nc * nv  * sizeof *(d->monos));
  d->ords         = malloc(d->nc       * sizeof *(d->ords));
  d->hpoly_To_idx = malloc((d->mo + 2) * sizeof *(d->hpoly_To_idx));
  assert(d->monos);
  assert(d->ords);
  assert(d->hpoly_To_idx);

  // ord 0
  mono_set(nv, d->monos, 0);
  d->hpoly_To_idx[0] = d->ords[0] = 0;
  int curr_mono_idx = 1;

  // ord 1
  d->hpoly_To_idx[1] = 1;
  d->hpoly_To_idx[2] = nv + 1;
  for (int i = 1; i <= nv; ++i)
  for (int j = 0; j <  nv; ++j)
    d->monos[i*nv + j] = 0;        // init with 0
  for (int i = 0; i < nv; ++i)
    if (d->a[i] >= 1) {            // set 1 on main diag, if possible
      d->monos[curr_mono_idx*nv + i] = 1;
      d->ords [curr_mono_idx]        = 1;
      curr_mono_idx++;
    }

  int real_nc = curr_mono_idx;
  if (d->mo >= 2)
    real_nc = make_higher_ord_monos(d, curr_mono_idx, need_realloc);

  tbl_realloc_monos(d, real_nc);
  d->size += real_nc * d->nv * sizeof *(d->monos);
  d->size += real_nc         * sizeof *(d->ords);
  d->size += (d->mo + 2)     * sizeof *(d->hpoly_To_idx);
}

static inline int
find_index(int n, const ord_t **T, const ord_t m[n], int start, int stop)
{
  assert(T && m);
  for (int i = start; i < stop; ++i)
    if (mono_equ(n,T[i],m)) return i;

  // error
  printf("monomial not found in table: ");
  mono_print(n,m);
  assert(NULL);
  return -1;
}

static inline int
find_index_bin(int n, const ord_t **T, const ord_t m[n], int start, int stop)
{
#ifdef DEBUG
  mono_print(n,m);
  printf(" from %d to %d\n", start, stop);
#endif
  int count = stop - start, i = 0, step = 0;
  while (count > 0) {
    step = count / 2;
    i = start + step;
    if (mono_rpgeq(n,T[i],m))
      count = step;
    else {
      start = ++i;
      count -= step + 1;
    }
  }
  if (mono_equ(n,T[start], m))
    return start;

  // error
  printf("monomial not found in table: "); mono_print(n,m);
  printf("; reached to mono ");            mono_print(n,T[start]);
  assert(NULL);
  return -1;
}

static inline void
tbl_by_ord(D *d)
{
#ifdef TRACE
  printf("tbl_by_ord for %p\n", (void*)d);
#endif

  assert(d && d->a && d->hpoly_To_idx && d->monos);

  d->To    = malloc(d->nc * sizeof *(d->To));
  d->to2tv = malloc(d->nc * sizeof *(d->to2tv));
  assert(d->To);
  assert(d->to2tv);
  d->size += d->nc * sizeof *(d->To);
  d->size += d->nc * sizeof *(d->to2tv);

  ord_t *monos = d->monos;
  for (int i = 0; i < d->nc; ++i, monos += d->nv)
    d->To[i]  = monos;
}

static inline void
tbl_by_var(D *d)
{
#ifdef TRACE
  printf("tbl_by_var for %p\n", (void*)d);
#endif
  assert(d && d->a && d->monos && d->hpoly_To_idx);

  d->Tv    = malloc(d->nc * sizeof *(d->Tv));
  d->tv2to = malloc(d->nc * sizeof *(d->tv2to));
  assert(d->Tv);
  assert(d->tv2to);
  d->size += d->nc * sizeof *(d->Tv);
  d->size += d->nc * sizeof *(d->tv2to);

  int mi = 0, nv = d->nv;
  ord_t m[nv];
  mono_set(nv, m, 0);
  do {
    int o = mono_sum(nv, m);
    int idx = find_index_bin(nv, (const ord_t**)d->To, m,
                             d->hpoly_To_idx[o], d->hpoly_To_idx[o+1]);
    d->tv2to[mi]  = idx;
    d->to2tv[idx] = mi;
    d->Tv[mi]   = d->To[idx];
    ++mi;
  } while (nxt_mono_by_var(d,nv,m));
#ifdef DEBUG
  tbl_print(nv, imin(mi,50), d->Tv);
  if (mi > 50) printf("... [ %d more rows ] ...\n", mi - 50);
  printf("tv2to=[ ");
  for (int i = 0; i < imin(mi,50); ++i) printf("%d ", d->tv2to[i]);
  printf("%s]\n", mi > 50 ? " ... " : "");
#endif
}

// --- H indexing matrix ------------------------------------------------------

static inline void
tbl_print_H(const D *d)
{
  assert(d && d->H);
  int cols = d->mo + 2;
  for (int i = 0; i < d->nv; ++i) {
    for (int j = 0; j < cols; ++j)
      printf("%2d ", d->H[i*cols + j]);
    printf("\n");
  }
}

static inline int
tbl_index_H(const D *d, int n, const ord_t m[n])
{
  assert(d);
  assert(n <= d->nv);
  int s = 0, I = 0, cols = d->mo + 2;
  const int *H = d->H;
  for (int i = n - 1; i >= 0; --i) {
    I += H[i*cols + s+m[i]] - H[i*cols + s];
    s += m[i];
  }
  assert(I > -1);
  return I;
}

static inline idx_t
desc_get_idx(const D *d, int n, const ord_t m[n])
{
  assert(d && m);
  assert(desc_mono_isvalid(d, n, m));
  return d->tv2to[tbl_index_H(d,n,m)];
}

static inline void
tbl_clear_H(D *d)
{
  int cols = d->mo + 2, accum = 0;
  for (int i = d->nv - 1; i >= 0; --i) {
    accum += d->a[i];
    for (int j = 1 + imin(accum,d->mo); j < cols; ++j)
      d->H[i*cols + j] = -1;
  }
}

static inline void
tbl_solve_H(D *d)
{
  int nv = d->nv, cols = d->mo + 2, accum = d->a[nv-1];
  ord_t b[nv], *a = d->a;

  // solve system of equations
  for (int i = nv-2; i >= 1; --i) { // variables
    accum += a[i];
    for (int j = a[i]+2; j <= imin(accum,d->mo); j++) { // orders
      nxt_mono_by_unk(nv,a,i,j,b);
      idx_t idx0 = tbl_index_H(d,nv,b);
      idx_t idx1 = find_index_bin(nv,(const ord_t**)d->Tv,b,idx0,d->nc);
      d->H[i*cols + j] = idx1 - idx0;
    }
  }
}

static inline void
tbl_build_H(idx_t *H, int rows, int cols, ord_t a[rows], const ord_t **Tv, int nc)
{
  // minimal constants for 1st row
  for (int j=0; j < cols; ++j)
    H[0*cols + j] = j;

  // remaining rows
  for (int i = 1; i < rows; ++i) {  // variables
    H[i*cols + 0] = 0;
    int crtPos = 1;

    // initial congruence from Tv
    for (int j = 1; j < nc; j++) { // monomials
      if (Tv[j][i] != Tv[j-1][i]) {
        H[i*cols + crtPos] = j;
        crtPos++;
        if (Tv[j][i] == 0) break;
      }
    }

    // complete row with zeros
    while(crtPos < cols) H[i*cols + crtPos] = 0, crtPos++;
  }

  // close congruence of the last var
  H[(rows-1)*cols + a[rows-1] + 1] = nc;
}

static inline void
tbl_set_H(D *d)
{
  assert(d && d->a && d->Tv && d->To);
  assert(d->nv != 0 && d->mo != 0 && d->nc != 0);
#ifdef TRACE
  printf("tbl_set_H for %p\n", (void*)d);
#endif

  d->H = malloc(d->nv * (d->mo+2) * sizeof *(d->H));
  assert(d->H);
  d->size += d->nv * (d->mo+2) * sizeof *(d->H);

  tbl_build_H(d->H, d->nv, d->mo + 2, d->a, (const ord_t**)d->Tv, d->nc);
  tbl_solve_H(d);
  tbl_clear_H(d);

#ifdef DEBUG
  printf("H = {\n");
  tbl_print_H(d);
#endif
}

// --- L indexing matrix ------------------------------------------------------

static inline void
tbl_print_LC(const idx_t *lc, int oa, int ob, int *pi)
{
  int iao = pi[oa], ibo = pi[ob], cols = pi[oa+1] - pi[oa];
  for (int ib = pi[ob]; ib < pi[ob+1]; ++ib) {
    printf("\n  ");
    for (int ia = pi[oa]; ia < pi[oa+1]; ++ia) {
      int ic;
      if (oa == ob) {
        if (ia > ib) break;
        ic = lc[hpoly_idx_triang(ia-iao,ib-ibo)];  // swap them to print left triang
      }
      else
        ic = lc[hpoly_idx_rect  (ib-ibo,ia-iao,cols)];
      printf("%3d ", ic);
    }
  }
  printf("\n");
}

static inline void
tbl_print_L(const D *d)
{
  int ho = d->mo / 2;
  for (int oc = 2; oc <= d->mo; ++oc)
    for (int j = 1; j <= oc/2; ++j) {
      int oa = oc - j, ob = j;
      printf("L[%d][%d] = {", oa, ob);
      tbl_print_LC(d->L[oa*ho + ob], oa, ob, d->hpoly_To_idx);
    }
}

static inline idx_t*
tbl_build_LC(int oa, int ob, D *d)
{
#ifdef DEBUG
  printf("tbl_set_LC oa=%d ob=%d\n", oa, ob);
#endif
  assert(d && d->To && d->hpoly_To_idx && d->tv2to);
  assert(oa < d->mo && ob < d->mo);

  ord_t **To = d->To;
  const int *pi   = d->hpoly_To_idx,  *i    = d->tv2to,          // shorter names
             iao  = pi[oa],            ibo  = pi[ob],            // offsets
             cols = pi[oa+1] - pi[oa], rows = pi[ob+1] - pi[ob]; // sizes

  int mat_size = 0;
  if (oa == ob) mat_size = ((rows + 1) * cols) / 2;
  else          mat_size = rows * cols;
  idx_t *lc = malloc(mat_size * sizeof *lc);
  assert(lc);
  d->size += mat_size * sizeof *lc;
  for (int i = 0; i < mat_size; ++i) lc[i] = -1;

  ord_t m[d->nv];
  int ic, ilc;
  for (int ib =      pi[ob]    ; ib < pi[ob+1]; ++ib)
  for (int ia = imax(pi[oa],ib); ia < pi[oa+1]; ++ia) {
    mono_add(d->nv, To[ia], To[ib], m);
    if (desc_mono_isvalid(d,d->nv,m)) {
      ic = i[tbl_index_H(d,d->nv,m)];
      if (oa == ob) ilc = hpoly_idx_triang(ib-ibo, ia-iao);
      else          ilc = hpoly_idx_rect  (ib-ibo, ia-iao, cols);
      lc[ilc] = ic;

#ifdef DEBUG
      /*
      printf(" ib=%d ", ib); mono_print(d->nv, To[ib]);
      printf(" ia=%d ", ia); mono_print(d->nv, To[ia]);
      printf(" ic=%d ", ic); mono_print(d->nv, m);
      printf(" ilc=%d\n", ilc);
      */
#endif
    }
  }

  return lc;
}

static inline void
tbl_set_L(D *d)
{
#ifdef TRACE
  printf("tbl_set_L from %p\n", (void*)d);
#endif
  ord_t o = d->mo, ho = d->mo / 2;
  d->L = malloc((o*ho + 1) * sizeof *(d->L));
  assert(d->L);
  d->size += (o*ho + 1) * sizeof *(d->L);

  for (int oc = 2; oc <= d->mo; ++oc)
    for (int j = 1; j <= oc / 2; ++j) {
      int oa = oc - j, ob = j;

      d->L[oa*ho + ob] = tbl_build_LC(oa, ob, d);
    }
#ifdef DEBUG
  tbl_print_L(d);
#endif
}

// --- UNIT TEST --------------------------------------------------------------

static inline int
tbl_check_L(D *d)
{
  assert(d && d->hpoly_To_idx && d->L && d->a && d->To && d->H);
  int ho = d->mo / 2, *pi = d->hpoly_To_idx;
  ord_t m[d->nv];
  for (int oc = 2; oc <= d->mo; ++oc)
    for (int j = 1; j <= oc / 2; ++j) {
      int oa = oc - j, ob = j;
      idx_t *lc = d->L[oa*ho + ob];
      if (!lc)                                   return  1e7 + oa*1e3 + ob;

      int sa = pi[oa+1]-pi[oa], sb = pi[ob+1]-pi[ob];

      for (int ibl =                   0 ; ibl < sb; ++ibl) {
      for (int ial = (oa == ob ? ibl : 0); ial < sa; ++ial) {
        int ib = ibl + pi[ob], ia = ial + pi[oa];
        int il = (oa == ob ?
                  hpoly_idx_triang(ibl,ial) : hpoly_idx_rect(ibl,ial,sa));
        if (il < 0)                              return -2e7 - ia*1e5 - ib;
        if (il >= sa * sb)                       return  2e7 + ia*1e5 + ib;

        int ic = lc[il];
        if (ic >= pi[oc+1])                      return  3e7 + ic*1e5 + 11;
        if (ic >= 0 && ic < d->hpoly_To_idx[oc]) return  3e7 + ic*1e5 + 12;

        mono_add(d->nv, d->To[ia], d->To[ib], m);
        if (ic < 0 && desc_mono_isvalid(d,d->nv,m))
                                                 return -3e7          - 13;
        }
      }
    }
  return 0;
}

static inline int  // error code
tbl_check(D *d)
{
  ord_t **Tv = d->Tv, **To = d->To, *monos = d->monos, *a = d->a;
  int *tv2to = d->tv2to, *to2tv = d->to2tv, nv = d->nv, cols = d->mo + 2;
  idx_t *H = d->H;

  // check H
  for (int i = 0; i < nv; ++i)
    if (H[i*cols + 0] != 0)                   return 1e6 + i;
  for (int i = 1; i < nv; ++i)
    if (a[i] == 0) {
      for (int j = 1; j <= d->mo + 1; ++j)
        if (H[i*cols + j] != -1)              return 2e6 + i;
    }
    else if (H[i*cols + 1] != (H[(i-1)*cols + a[i-1] + 1] != -1 ?
                          H[(i-1)*cols + a[i-1] + 1] : H[(i-1)*cols + a[i-1]] + 1))
                                              return 3e6 + i;

  for (int i = 1; i < d->nc; ++i) {
    if (to2tv[tv2to[i]] != i)                 return 4e6 + i;
    if (tv2to[tbl_index_H(d,nv,To[i])] != i)  return 5e6 + i;
    if (! mono_equ(nv,To[tv2to[i]],Tv[i]))    return 6e6 + i;
    if (! mono_equ(nv,To[i],monos + nv*i))    return 7e6 + i;
  }
  return tbl_check_L(d);
}

// --- DESC management --------------------------------------------------------

enum { TPSA_DESC_NUM = 1000 };    // number of descriptors to store

static D  *Ds[TPSA_DESC_NUM];
static int last_desc_idx = -1;

static inline D*
desc_new(int nv, const ord_t var_ords[nv], ord_t mvo, ord_t mko, int knb_start)
{
#ifdef TRACE
  printf("desc_new nv=%d mo=%d nc=%d ks=%d var_ords=",
         nv, mvo, max_nc(nv, mvo), knb_start);
  mono_print(nv, var_ords);
  printf("\n");
#endif

  D *d = malloc(sizeof *d);
  assert(d);
  d->nv = nv, d->mo = mvo, d->mko = mko;
  d->knb_start = knb_start;
  d->size = sizeof(d);

  d->a = malloc(nv * sizeof *(d->a));
  assert(d->a);
  mono_cpy(nv, var_ords, d->a);
  d->size += nv * sizeof *(d->a);

  make_monos(d);
  tbl_by_ord(d);
  tbl_by_var(d);  // requires To
  tbl_set_H(d);
  tbl_set_L(d);

#ifdef TRACE
  printf("  Total desc size: %d bytes\n", d->size);
#endif

  int err = tbl_check(d);
  if (err != 0) {
    // printf("\nA= ");   mono_print(d->nv, d->a);
    // printf("\nH=\n");  tbl_print_H(d);
    // printf("\nTv=\n"); tbl_print(d->nv, d->nc, d->Tv);
    // printf("\nTo=\n"); tbl_print(d->nv, d->nc, d->To);
    printf("\nCheking table consistency ... %d\n", err);
    assert(NULL);
  }

  return d;
}

static inline int
desc_equ(const D *d, int nv, const ord_t var_ords[nv], ord_t mvo, ord_t mko, int knb_start)
{
  assert(d && d->a);
  assert(var_ords);
  return d->nv == nv && d->mo == mvo && d->mko == mko
                     && d->knb_start == knb_start && mono_equ(nv, d->a, var_ords);
}

static inline D*
desc_search(int nv, const ord_t var_ords[nv], ord_t mvo, ord_t mko, int knb_start)
{
  for (int i = last_desc_idx; i >= 0; --i) {
    if (desc_equ(Ds[i], nv, var_ords, mvo, mko, knb_start))
      return Ds[i];
  }
  return NULL;
}

// --- Public Functions -------------------------------------------------------

D*
mad_tpsa_desc_new (int nv, const ord_t var_ords[nv], ord_t mvo)
{
  D *d = desc_search(nv,var_ords,mvo,0,nv);
  return d ? d : (Ds[++last_desc_idx] = desc_new(nv, var_ords, mvo, 0, nv));
}

D*
mad_tpsa_desc_newk(int nv, const ord_t var_ords[nv], ord_t mvo,
                   int nk, const ord_t knb_ords[nk], ord_t mko)
{
  assert(var_ords && knb_ords);
  assert(mvo <= mko);
  ord_t ords[nv+nk];
  int io = 0;
  for (int i = 0; i < nv; ++i) ords[io++] = var_ords[i];
  for (int i = 0; i < nk; ++i) ords[io++] = knb_ords[i];
  D *d = desc_search(nv+nk, ords, mvo, mko, nv);
  return d ? d : (Ds[++last_desc_idx] = desc_new(nv+nk, ords, mvo, mko, nv));
}

void
mad_tpsa_desc_del(D *d)
{
  // free and set to NULL so that they cannot be accidentally reused
  free(d->hpoly_To_idx); d->hpoly_To_idx   = NULL;
  free(d->tv2to);        d->tv2to          = NULL;
  free(d->a);            d->a              = NULL;
  free(d->monos);        d->monos          = NULL;
  free(d->To);           d->To             = NULL;
  free(d->Tv);           d->Tv             = NULL;
  free(d->H);            d->H              = NULL;

  for (int i = 0; i < d->mo*d->mo/2; ++i) {
    free(d->L[i]);       d->L[i]           = NULL;
  }
  free(d->L);            d->L              = NULL;

  // find and remove descriptor from global array
  int idx = 0;
  while (d != Ds[idx++]);
  for ( ; idx <= last_desc_idx; ++idx)
    Ds[idx-1] = Ds[idx];
  last_desc_idx--;

  free(d);
}

int
mad_tpsa_desc_nc(const D *d)
{
  assert(d);
  return d->nc;
}

#undef D
#undef TRACE
#undef DEBUG
