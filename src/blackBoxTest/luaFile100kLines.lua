local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end

local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end
local help = [[
	This is meant to be a huge lua-file of aprox. 20k lines for testing the speed of the parser. Code will be used from several different places on the web.
]]

do


	g_currentModDirectory = "."
	courseplay = {
		      path = g_currentModDirectory,
		      
		      -- place them here in order to get an overview of the contents of the courseplay object
		      utils = {};
		      courses = {};
		      settings = {};
		      hud = {};
		      button = {};
		      fields = {};
		      thirdParty = {
		              EifokLiquidManure = {
		                      dockingStations = {};
		                      KotteContainers = {};
		                      KotteZubringers = {};
		                      hoses = {};
		              };
		      };
	};
	-------------------------------------------UNDERSCORE-------------------------------------------------------------
	--
	-- Copyright (c) 2009 Marcus Irven
	-- 
	-- Permission is hereby granted, free of charge, to any person
	-- obtaining a copy of this software and associated documentation
	-- files (the "Software"), to deal in the Software without
	-- restriction, including without limitation the rights to use,
	-- copy, modify, merge, publish, distribute, sublicense, and/or sell
	-- copies of the Software, and to permit persons to whom the
	-- Software is furnished to do so, subject to the following
	-- conditions:
	-- 
	-- The above copyright notice and this permission notice shall be
	-- included in all copies or substantial portions of the Software.
	-- 
	-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	-- EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	-- OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	-- NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	-- HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	-- WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	-- FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	-- OTHER DEALINGS IN THE SOFTWARE.

	--- Underscore is a set of utility functions for dealing with
	-- iterators, arrays, tables, and functions.

	local Underscore = { funcs = {} }
	Underscore.__index = Underscore

	function Underscore.__call(_, value)
		      return Underscore:new(value)
	end

	function Underscore:new(value, chained)
		      return setmetatable({ _val = value, chained = chained or false }, self)
	end

	function Underscore.iter(list_or_iter)
		      if type(list_or_iter) == "function" then return list_or_iter end
		      
		      return coroutine.wrap(function()
		              for i=1,#list_or_iter do
		                      coroutine.yield(list_or_iter[i])
		              end
		      end)
	end

	function Underscore.range(start_i, end_i, step)
		      if end_i == nil then
		              end_i = start_i
		              start_i = 1
		      end
		      step = step or 1
		      local range_iter = coroutine.wrap(function()
		              for i=start_i, end_i, step do
		                      coroutine.yield(i)
		              end
		      end)
		      return Underscore:new(range_iter)
	end

	--- Identity function. This function looks useless, but is used throughout Underscore as a default.
	-- @name _.identity
	-- @param value any object
	-- @return value
	-- @usage _.identity("foo")
	-- => "foo"
	function Underscore.identity(value)
		      return value
	end

	-- chaining

	function Underscore:chain()
		      self.chained = true
		      return self
	end

	function Underscore:value()
		      return self._val
	end

	-- iter

	function Underscore.funcs.each(list, func)
		      for i in Underscore.iter(list) do
		              func(i)
		      end
		      return list
	end

	function Underscore.funcs.map(list, func)
		      local mapped = {}
		      for i in Underscore.iter(list) do
		              mapped[#mapped+1] = func(i)
		      end        
		      return mapped
	end

	function Underscore.funcs.reduce(list, memo, func)        
		      for i in Underscore.iter(list) do
		              memo = func(memo, i)
		      end        
		      return memo
	end

	function Underscore.funcs.detect(list, func)
		      for i in Underscore.iter(list) do
		              if func(i) then return i end
		      end        
		      return nil        
	end

	function Underscore.funcs.select(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.reject(list, func)
		      local selected = {}
		      for i in Underscore.iter(list) do
		              if not func(i) then selected[#selected+1] = i end
		      end
		      return selected
	end

	function Underscore.funcs.all(list, func)
		      func = func or Underscore.identity
		      
		      -- TODO what should happen with an empty list?
		      for i in Underscore.iter(list) do
		              if not func(i) then return false end
		      end
		      return true
	end

	function Underscore.funcs.any(list, func)
		      func = func or Underscore.identity

		      -- TODO what should happen with an empty list?        
		      for i in Underscore.iter(list) do
		              if func(i) then return true end
		      end        
		      return false
	end

	function Underscore.funcs.include(list, value)
		      for i in Underscore.iter(list) do
		              if i == value then return true end
		      end        
		      return false
	end

	function Underscore.funcs.invoke(list, function_name, ...)
		      local args = {...}
		      Underscore.funcs.each(list, function(i) i[function_name](i, unpack(args)) end)
		      return list
	end

	function Underscore.funcs.pluck(list, propertyName)
		      return Underscore.funcs.map(list, function(i) return i[propertyName] end)
	end

	function Underscore.funcs.min(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(min, item)
		              if min.item == nil then
		                      min.item = item
		                      min.value = func(item)
		              else
		                      local value = func(item)
		                      if value < min.value then
		                              min.item = item
		                              min.value = value
		                      end
		              end
		              return min
		      end).item
	end

	function Underscore.funcs.max(list, func)
		      func = func or Underscore.identity
		      
		      return Underscore.funcs.reduce(list, { item = nil, value = nil }, function(max, item)
		              if max.item == nil then
		                      max.item = item
		                      max.value = func(item)
		              else
		                      local value = func(item)
		                      if value > max.value then
		                              max.item = item
		                              max.value = value
		                      end
		              end
		              return max
		      end).item
	end

	function Underscore.funcs.to_array(list)
		      local array = {}
		      for i in Underscore.iter(list) do
		              array[#array+1] = i
		      end        
		      return array
	end

	function Underscore.funcs.reverse(list)
		      local reversed = {}
		      for i in Underscore.iter(list) do
		              table.insert(reversed, 1, i)
		      end        
		      return reversed
	end

	function Underscore.funcs.sort(iter, comparison_func)
		      local array = iter
		      if type(iter) == "function" then
		              array = Underscore.funcs.to_array(iter)
		      end
		      table.sort(array, comparison_func)
		      return array
	end

	-- arrays

	function Underscore.funcs.first(array, n)
		      if n == nil then
		              return array[1]
		      else
		              local first = {}
		              n = math.min(n,#array)
		              for i=1,n do
		                      first[i] = array[i]                        
		              end
		              return first
		      end
	end

	function Underscore.funcs.rest(array, index)
		      index = index or 2
		      local rest = {}
		      for i=index,#array do
		              rest[#rest+1] = array[i]
		      end
		      return rest
	end

	function Underscore.funcs.slice(array, start_index, length)
		      local sliced_array = {}
		      
		      start_index = math.max(start_index, 1)
		      local end_index = math.min(start_index+length-1, #array)
		      for i=start_index, end_index do
		              sliced_array[#sliced_array+1] = array[i]
		      end
		      return sliced_array
	end

	function Underscore.funcs.flatten(array)
		      local all = {}
		      
		      for ele in Underscore.iter(array) do
		              if type(ele) == "table" then
		                      local flattened_element = Underscore.funcs.flatten(ele)
		                      Underscore.funcs.each(flattened_element, function(e) all[#all+1] = e end)
		              else
		                      all[#all+1] = ele
		              end
		      end
		      return all
	end

	function Underscore.funcs.push(array, item)
		      table.insert(array, item)
		      return array
	end

	function Underscore.funcs.pop(array)
		      return table.remove(array)
	end

	function Underscore.funcs.shift(array)
		      return table.remove(array, 1)
	end

	function Underscore.funcs.unshift(array, item)
		      table.insert(array, 1, item)
		      return array
	end

	function Underscore.funcs.join(array, separator)
		      return table.concat(array, separator)
	end

	-- objects

	function Underscore.funcs.keys(obj)
		      local keys = {}
		      for k,v in pairs(obj) do
		              keys[#keys+1] = k
		      end
		      return keys
	end

	function Underscore.funcs.values(obj)
		      local values = {}
		      for k,v in pairs(obj) do
		              values[#values+1] = v
		      end
		      return values
	end

	function Underscore.funcs.extend(destination, source)
		      for k,v in pairs(source) do
		              destination[k] = v
		      end        
		      return destination
	end

	function Underscore.funcs.is_empty(obj)
		      return next(obj) == nil
	end

	-- Originally based on penlight's deepcompare() -- http://luaforge.net/projects/penlight/
	function Underscore.funcs.is_equal(o1, o2, ignore_mt)
		      local ty1 = type(o1)
		      local ty2 = type(o2)
		      if ty1 ~= ty2 then return false end
		      
		      -- non-table types can be directly compared
		      if ty1 ~= 'table' then return o1 == o2 end
		      
		      -- as well as tables which have the metamethod __eq
		      local mt = getmetatable(o1)
		      if not ignore_mt and mt and mt.__eq then return o1 == o2 end
		      
		      local is_equal = Underscore.funcs.is_equal
		      
		      for k1,v1 in pairs(o1) do
		              local v2 = o2[k1]
		              if v2 == nil or not is_equal(v1,v2, ignore_mt) then return false end
		      end
		      for k2,v2 in pairs(o2) do
		              local v1 = o1[k2]
		              if v1 == nil then return false end
		      end
		      return true
	end

	-- functions

	function Underscore.funcs.compose(...)
		      local function call_funcs(funcs, ...)
		              if #funcs > 1 then
		                      return funcs[1](call_funcs(_.rest(funcs), ...))
		              else
		                      return funcs[1](...)
		              end
		      end
		      
		      local funcs = {...}
		      return function(...)
		              return call_funcs(funcs, ...)
		      end
	end

	function Underscore.funcs.wrap(func, wrapper)
		      return function(...)
		              return wrapper(func, ...)
		      end
	end

	function Underscore.funcs.curry(func, argument)
		      return function(...)
		              return func(argument, ...)
		      end
	end

	function Underscore.functions()
		      return Underscore.keys(Underscore.funcs)
	end

	-- add aliases
	Underscore.methods = Underscore.functions

	Underscore.funcs.for_each = Underscore.funcs.each
	Underscore.funcs.collect = Underscore.funcs.map
	Underscore.funcs.inject = Underscore.funcs.reduce
	Underscore.funcs.foldl = Underscore.funcs.reduce
	Underscore.funcs.filter = Underscore.funcs.select
	Underscore.funcs.every = Underscore.funcs.all
	Underscore.funcs.some = Underscore.funcs.any
	Underscore.funcs.head = Underscore.funcs.first
	Underscore.funcs.tail = Underscore.funcs.rest

	local function wrap_functions_for_oo_support()
		      local function value_and_chained(value_or_self)
		              local chained = false
		              if getmetatable(value_or_self) == Underscore then
		                      chained = value_or_self.chained
		                      value_or_self = value_or_self._val
		              end
		              return value_or_self, chained
		      end

		      local function value_or_wrap(value, chained)
		              if chained then value = Underscore:new(value, true) end
		              return value
		      end

		      for fn, func in pairs(Underscore.funcs) do
		              Underscore[fn] = function(obj_or_self, ...)
		                      local obj, chained = value_and_chained(obj_or_self)        
		                      return value_or_wrap(func(obj, ...), chained)                
		              end        
		      end
	end

	wrap_functions_for_oo_support()

	local Underscore = Underscore:new()


	---------------------------------END OF UNDERSCORDE-----------------------------------------------------------

	-----------------------------------MOONSCRIPT UTIL --------------------------------------------------------

	local concat
	do
		local _obj_0 = table
		concat = _obj_0.concat
	end
	local unpack = unpack or table.unpack
	local type = type
	local moon = {
		is_object = function(value)
		  return type(value) == "table" and value.__class
		end,
		is_a = function(thing, t)
		  if not (type(thing) == "table") then
		    return false
		  end
		  local cls = thing.__class
		  while cls do
		    if cls == t then
		      return true
		    end
		    cls = cls.__parent
		  end
		  return false
		end,
		type = function(value)
		  local base_type = type(value)
		  if base_type == "table" then
		    local cls = value.__class
		    if cls then
		      return cls
		    end
		  end
		  return base_type
		end
	}
	local pos_to_line
	pos_to_line = function(str, pos)
		local line = 1
		for _ in str:sub(1, pos):gmatch("\n") do
		  line = line + 1
		end
		return line
	end
	local trim
	trim = function(str)
		return str:match("^%s*(.-)%s*$")
	end
	local get_line
	get_line = function(str, line_num)
		for line in str:gmatch("([^\n]*)\n?") do
		  if line_num == 1 then
		    return line
		  end
		  line_num = line_num - 1
		end
	end
	local get_closest_line
	get_closest_line = function(str, line_num)
		local line = get_line(str, line_num)
		if (not line or trim(line) == "") and line_num > 1 then
		  return get_closest_line(str, line_num - 1)
		else
		  return line, line_num
		end
	end
	local reversed
	reversed = function(seq)
		return coroutine.wrap(function()
		  for i = #seq, 1, -1 do
		    coroutine.yield(i, seq[i])
		  end
		end)
	end
	local split
	split = function(str, delim)
		if str == "" then
		  return { }
		end
		str = str .. delim
		local _accum_0 = { }
		local _len_0 = 1
		for m in str:gmatch("(.-)" .. delim) do
		  _accum_0[_len_0] = m
		  _len_0 = _len_0 + 1
		end
		return _accum_0
	end
	local dump
	dump = function(what)
		local seen = { }
		local _dump
		_dump = function(what, depth)
		  if depth == nil then
		    depth = 0
		  end
		  local t = type(what)
		  if t == "string" then
		    return '"' .. what .. '"\n'
		  elseif t == "table" then
		    if seen[what] then
		      return "recursion(" .. tostring(what) .. ")...\n"
		    end
		    seen[what] = true
		    depth = depth + 1
		    local lines
		    do
		      local _accum_0 = { }
		      local _len_0 = 1
		      for k, v in pairs(what) do
		        _accum_0[_len_0] = (" "):rep(depth * 4) .. "[" .. tostring(k) .. "] = " .. _dump(v, depth)
		        _len_0 = _len_0 + 1
		      end
		      lines = _accum_0
		    end
		    seen[what] = false
		    return "{\n" .. concat(lines) .. (" "):rep((depth - 1) * 4) .. "}\n"
		  else
		    return tostring(what) .. "\n"
		  end
		end
		return _dump(what)
	end
	local debug_posmap
	debug_posmap = function(posmap, moon_code, lua_code)
		local tuples
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for k, v in pairs(posmap) do
		    _accum_0[_len_0] = {
		      k,
		      v
		    }
		    _len_0 = _len_0 + 1
		  end
		  tuples = _accum_0
		end
		table.sort(tuples, function(a, b)
		  return a[1] < b[1]
		end)
		local lines
		do
		  local _accum_0 = { }
		  local _len_0 = 1
		  for _index_0 = 1, #tuples do
		    local pair = tuples[_index_0]
		    local lua_line, pos = unpack(pair)
		    local moon_line = pos_to_line(moon_code, pos)
		    local lua_text = get_line(lua_code, lua_line)
		    local moon_text = get_closest_line(moon_code, moon_line)
		    local _value_0 = tostring(pos) .. "\t " .. tostring(lua_line) .. ":[ " .. tostring(trim(lua_text)) .. " ] >> " .. tostring(moon_line) .. ":[ " .. tostring(trim(moon_text)) .. " ]"
		    _accum_0[_len_0] = _value_0
		    _len_0 = _len_0 + 1
		  end
		  lines = _accum_0
		end
		return concat(lines, "\n")
	end
	local setfenv = setfenv or function(fn, env)
		local name
		local i = 1
		while true do
		  name = debug.getupvalue(fn, i)
		  if not name or name == "_ENV" then
		    break
		  end
		  i = i + 1
		end
		if name then
		  debug.upvaluejoin(fn, i, (function()
		    return env
		  end), 1)
		end
		return fn
	end
	local getfenv = getfenv or function(fn)
		local i = 1
		while true do
		  local name, val = debug.getupvalue(fn, i)
		  if not (name) then
		    break
		  end
		  if name == "_ENV" then
		    return val
		  end
		  i = i + 1
		end
		return nil
	end
	local get_options
	get_options = function(...)
		local count = select("#", ...)
		local opts = select(count, ...)
		if type(opts) == "table" then
		  return opts, unpack({
		    ...
		  }, nil, count - 1)
		else
		  return { }, ...
		end
	end
	MoonscriptUtil = {
		moon = moon,
		pos_to_line = pos_to_line,
		get_closest_line = get_closest_line,
		get_line = get_line,
		reversed = reversed,
		trim = trim,
		split = split,
		dump = dump,
		debug_posmap = debug_posmap,
		getfenv = getfenv,
		setfenv = setfenv,
		get_options = get_options,
		unpack = unpack
	}

	-----------------------------END MOONSCRIPT UTIL -----------------------------------------------



	--------------------------- ASTAR---------------------------------------------
	--[[
	A* algorithm for LUA
	Ported to LUA by Altair
	21 septembre 2006
	courseplay edit by hummel 2011
	--]]


	function round(num, idp)
		      return math.floor(num / idp) * idp
	end

	function CalcMoves(px, py, tx, ty, fruit_type) -- Based on some code of LMelior but made it work and improved way beyond his code, still thx LMelior!
		      if not courseplay:is_field(py, px) then
		              return nil
		      end

		      local interval = 5
		      local vertical_costs = 10
		      local diagnoal_costs = 14

		      px = round(px, interval)
		      py = round(py, interval)
		      tx = round(tx, interval)
		      ty = round(ty, interval)

		      --[[ PRE:
	mapmat is a 2d array
	px is the player's current x
	py is the player's current y
	tx is the target x
	ty is the target y

	Note: all the x and y are the x and y to be used in the table.
	By this I mean, if the table is 3 by 2, the x can be 1,2,3 and the y can be 1 or 2.
	--]]

		      --[[ POST:
	closedlist is a list with the checked nodes.
	It will return nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      -- variables
		      local openlist = {} -- Initialize table to store possible moves
		      local closedlist = {} -- Initialize table to store checked gridsquares
		      local listk = 1 -- List counter
		      local closedk = 0 -- Closedlist counter
		      local tempH = math.abs(px - tx) + math.abs(py - ty)
		      local tempG = 0
		      openlist[1] = { x = px, y = py, g = 0, h = tempH, f = 0 + tempH, par = 1 } -- Make starting point in list
		      local xsize = 1024 -- horizontal map size
		      local ysize = 1024 -- vertical map size
		      local curbase = {} -- Current square from which to check possible moves
		      local basis = 1 -- Index of current base
		      local max_tries = 2000
		      local max_distance_factor = 10
		      local air_distance = tempH

		      -- Growing loop
		      while listk > 0 do

		              -- Get the lowest f of the openlist
		              local lowestF = openlist[listk].f
		              basis = listk
		              for k = listk, 1, -1 do
		                      if openlist[k].f < lowestF then
		                              lowestF = openlist[k].f
		                              basis = k
		                      end
		              end

		              if closedk >= max_tries then
		                      return nil
		              end

		              closedk = closedk + 1
		              table.insert(closedlist, closedk, openlist[basis])

		              curbase = closedlist[closedk] -- define current base from which to grow list

		              --courseplay:debug(string.format("a star check x: %f y %f - closedk: %d", curbase.x, curbase.y, closedk ), 4)

		              local wOK = true
		              local eOK = true -- Booleans defining if they're OK to add
		              local sOK = true -- (must be reset for each while loop)
		              local nOK = true

		              local nwOK = true
		              local seOK = true
		              local swOK = true
		              local noOK = true

		              -- Look through closedlist
		              if closedk > 0 then
			                      for k = 1, closedk do
	                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y then
		                                      wOK = false
		                              end
		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y then
		                                      eOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y + interval then
		                                      sOK = false
		                              end
		                              if closedlist[k].x == curbase.x and closedlist[k].y == curbase.y - interval then
		                                      nOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y - interval then
		                                      nwOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y - interval then
		                                      neOK = false
		                              end

		                              if closedlist[k].x == curbase.x + interval and closedlist[k].y == curbase.y + interval then
		                                      swOK = false
		                              end

		                              if closedlist[k].x == curbase.x - interval and closedlist[k].y == curbase.y + interval then
		                                      seOK = false
		                              end
		                      end
		              end

		              -- Check if next points are on the map and within moving distance
		              if curbase.x + interval > xsize then
		                      wOK = false
		                      nwOK = false
		                      swOK = false
		              end
		              if curbase.x - interval < -1024 then
		                      eOK = false
		                      neOK = false
		                      seOK = false
		              end
		              if curbase.y + interval > ysize then
		                      sOK = false
		                      swOK = false
		                      seOK = false
		              end
		              if curbase.y - interval < -1024 then
		                      nOK = false
		                      nwOK = false
		                      neOK = false
		              end

		              -- If it IS on the map, check map for obstacles
		              --(Lua returns an error if you try to access a table position that doesn't exist, so you can't combine it with above)
		              if wOK and curbase.x + interval <= xsize and courseplay:area_has_fruit(curbase.y, curbase.x + interval, fruit_type) then
		                      wOK = false
		              end
		              if eOK and curbase.x - interval >= -1024 and courseplay:area_has_fruit(curbase.y, curbase.x - interval, fruit_type) then
		                      eOK = false
		              end
		              if sOK and curbase.y + interval <= ysize and courseplay:area_has_fruit(curbase.y + interval, curbase.x, fruit_type) then
		                      sOK = false
		              end
		              if nOK and curbase.y - interval >= -1024 and courseplay:area_has_fruit(curbase.y - interval, curbase.x, fruit_type) then
		                      nOK = false
		              end

		              -- check if the move from the current base is shorter then from the former parrent
		              tempG = curbase.g + interval
		              for k = 1, listk do
		                      if wOK and openlist[k].x == curbase.x + interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("right OK 1", 4)
		                                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              wOK = false
		                      end

		                      if eOK and openlist[k].x == curbase.x - interval and openlist[k].y == curbase.y then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("left OK 1", 4)
		                                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                                      table.insert(openlist, k, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              eOK = false
		                      end

		                      if sOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y + interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("down OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y + interval - ty)

		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              sOK = false
		                      end

		                      if nOK and openlist[k].x == curbase.x and openlist[k].y == curbase.y - interval then
		                              if openlist[k].g > tempG then
		                                      --courseplay:debug("up OK 1", 4)
		                                      tempH = math.abs((curbase.x) - tx) + math.abs(curbase.y - interval - ty)
		                                      table.insert(openlist, k, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		                              end
		                              nOK = false
		                      end
		              end

		              -- Add points to openlist
		              -- Add point to the right of current base point
		              if wOK then
		                      --courseplay:debug("right OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x + interval) - tx) + math.abs(curbase.y - ty)

		                      table.insert(openlist, listk, { x = curbase.x + interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point to the left of current base point
		              if eOK then
		                      --courseplay:debug("left OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs((curbase.x - interval) - tx) + math.abs(curbase.y - ty)
		                      table.insert(openlist, listk, { x = curbase.x - interval, y = curbase.y, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the top of current base point
		              if sOK then
		                      --courseplay:debug("down OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y + interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y + interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              -- Add point on the bottom of current base point
		              if nOK then
		                      --courseplay:debug("up OK", 4)
		                      listk = listk + 1
		                      tempH = math.abs(curbase.x - tx) + math.abs((curbase.y - interval) - ty)

		                      table.insert(openlist, listk, { x = curbase.x, y = curbase.y - interval, g = tempG, h = tempH, f = tempG + tempH, par = closedk })
		              end

		              table.remove(openlist, basis)
		              listk = listk - 1

		              if closedlist[closedk].x == tx and closedlist[closedk].y == ty then
		                      return CalcPath(closedlist)
		              end
		      end
		      return nil
	end

	function CalcPath(closedlist)
		      --[[ PRE:
	closedlist is a list with the checked nodes.
	OR nil if all the available nodes have been checked but the target hasn't been found.
	--]]

		      --[[ POST:
	path is a list with all the x and y coords of the nodes of the path to the target.
	OR nil if closedlist==nil
	--]]

		      if closedlist == nil then
		              return nil
		      end
		      local path = {}
		      local pathIndex = {}
		      local last = table.getn(closedlist)
		      table.insert(pathIndex, 1, last)

		      local i = 1
		      while pathIndex[i] > 1 do
		              i = i + 1
		              table.insert(pathIndex, i, closedlist[pathIndex[i - 1]].par)
		      end

		      for n = table.getn(pathIndex), 1, -1 do
		              table.insert(path, { x = closedlist[pathIndex[n]].x, y = closedlist[pathIndex[n]].y })
		      end

		      closedlist = nil
		      return path
	end

	-------------------------------__END ASTAR ----------------------------------------------------------
end

